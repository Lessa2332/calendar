<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>–ú–∞–≥—ñ—á–Ω–∏–π –ø–∞–∑–ª –¥–ª—è –∑—ñ—Ä–æ—á–∫–∏</title>

  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@1.2.1/dist/mindar-image-aframe.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

  <style>
    body,html{margin:0;padding:0;height:100%;overflow:hidden;background:#000;font-family:'Comic Sans MS',sans-serif;touch-action:none}
    canvas{position:fixed;inset:0;z-index:100;display:none;cursor:grab;background:rgba(0,0,0,0.9)}
    canvas:active{cursor:grabbing}
    .screen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;color:white;z-index:999}
    #startScreen{background:radial-gradient(circle at center,#ff1493,#000)}
    #hintScreen{background:rgba(0,0,0,0.8);font-size:28px;display:none}
    #winScreen{background:rgba(0,0,0,0.95);color:gold;font-size:60px;display:none}
    #winScreen span{animation:bounce 1s infinite;margin-bottom:20px}
    @keyframes bounce{0%,100%{transform:scale(1)}50%{transform:scale(1.2)}}
    button{background:#ff1493;color:white;border:none;padding:20px 50px;border-radius:50px;font-size:30px;cursor:pointer;box-shadow:0 0 40px #ff1493}
    #closeBtn{position:fixed;top:20px;right:20px;width:60px;height:60px;font-size:30px;z-index:101;display:none;background:#ff1493;color:white;border:none;border-radius:50%}
    .mindar-ui-overlay,.mindar-ui-loading,.mindar-ui-scanning{display:none!important}
  </style>
</head>
<body>

  <canvas id="puzzleCanvas"></canvas>
  <button id="closeBtn">‚úï</button>

  <div id="startScreen" class="screen">
    <button id="startBtn">üéÆ –ü–û–ß–ê–¢–ò –ú–ê–ì–Ü–Æ! üéÆ</button>
  </div>
  <div id="hintScreen" class="screen">
    <div style="font-size: 32px; margin-bottom: 20px;">üîç –ü–æ–∫–∞–∂–∏ –º–∞—Ä–∫–µ—Ä –∫–∞–º–µ—Ä—ñ!</div>
    <div style="font-size: 24px; opacity: 0.8;">–ó–Ω–∞–π–¥–∏ —Å–ø–µ—Ü—ñ–∞–ª—å–Ω—ñ –∫–∞—Ä—Ç–∏–Ω–∫–∏ —Ç–∞ –∑–±–∏—Ä–∞–π –ø–∞–∑–ª–∏!</div>
  </div>
  <div id="winScreen" class="screen">
    <span>üéâ –£–†–ê–ê–ê! üéâ</span>
    <div style="font-size:40px">–¢–∏ —á–∞—Ä—ñ–≤–Ω–∏–π –º–∞–π—Å—Ç–µ—Ä –ø–∞–∑–ª—ñ–≤! ‚ú®</div>
  </div>

  <a-scene embedded mindar-image="imageTargetSrc: calendar.mind; autoStart: false;"
    renderer="colorManagement:true;antialias:true"
    vr-mode-ui="enabled:false" device-orientation-permission-ui="enabled:false">
    <a-camera active="false"></a-camera>
  </a-scene>

  <script>
    // ================================================
    // –ö–û–ù–§–Ü–ì–£–†–ê–¶–Ü–Ø –ü–ê–ó–õ–Ü–í (–≤—ñ–¥ 01 –¥–æ 12)
    // ================================================
    const PUZZLES = Array.from({length:12}, (_,i) => ({
      id: i,
      image: `images/${String(i+1).padStart(2,'0')}.jpg`,
      rows: 3,
      cols: 3
    }));

    // –ì–ª–æ–±–∞–ª—å–Ω–∞ –∑–º—ñ–Ω–Ω–∞ –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ –ø–∞–∑–ª—É
    let currentPuzzle = null;

    // ================================================
    // 1. EventBus ‚Äì –ø—Ä–æ—Å—Ç–∞ —à–∏–Ω–∞ –ø–æ–¥—ñ–π
    // ================================================
    class EventBus {
      constructor() { this.events = {}; }
      on(name, callback) { 
        if (!this.events[name]) this.events[name] = [];
        this.events[name].push(callback); 
      }
      off(name, callback) { 
        if (this.events[name]) {
          this.events[name] = this.events[name].filter(c => c !== callback);
        }
      }
      emit(name, data) { 
        if (this.events[name]) {
          this.events[name].forEach(cb => cb(data)); 
        }
      }
    }
    const bus = new EventBus();

    // ================================================
    // 2. ScreenManager
    // ================================================
    class ScreenManager {
      constructor() {
        this.screens = {
          start: document.getElementById('startScreen'),
          hint: document.getElementById('hintScreen'),
          win: document.getElementById('winScreen')
        };
        this.closeBtn = document.getElementById('closeBtn');
        this.canvas = document.getElementById('puzzleCanvas');
      }
      show(screenName) {
        // –•–æ–≤–∞—î–º–æ –≤—Å—ñ –µ–∫—Ä–∞–Ω–∏
        Object.values(this.screens).forEach(s => {
          if (s) s.style.display = 'none';
        });
        this.canvas.style.display = 'none';
        this.closeBtn.style.display = 'none';

        // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ—Ç—Ä—ñ–±–Ω–∏–π
        switch(screenName) {
          case 'start':
            this.screens.start.style.display = 'flex';
            break;
          case 'hint':
            this.screens.hint.style.display = 'flex';
            break;
          case 'puzzle':
            this.canvas.style.display = 'block';
            this.closeBtn.style.display = 'block';
            break;
          case 'win':
            this.screens.win.style.display = 'flex';
            break;
        }
      }
    }
    const screens = new ScreenManager();

    // ================================================
    // 3. ConfettiManager
    // ================================================
    class ConfettiManager {
      celebrate() {
        confetti({particleCount:200,spread:100,origin:{y:0.6}});
        setTimeout(() => confetti({particleCount:150,angle:60,spread:80,origin:{x:0}}),500);
        setTimeout(() => confetti({particleCount:150,angle:120,spread:80,origin:{x:1}}),1000);
      }
    }
    const confettiManager = new ConfettiManager();

    // ================================================
    // 4. –£—Ç–∏–ª—ñ—Ç–∏
    // ================================================
    const loadImage = src => new Promise((res,rej) => {
      const img = new Image();
      img.onload = () => res(img);
      img.onerror = () => rej(new Error(`–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ ${src}`));
      img.src = src;
    });

    // ================================================
    // 5. PuzzleRenderer (—Ç—ñ–ª—å–∫–∏ –º–∞–ª—é–≤–∞–Ω–Ω—è)
    // ================================================
    class PuzzleRenderer {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
      }
      resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
      }
      clear() { 
        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height); 
      }
      draw(pieces, dragged) {
        this.clear();
        
        if (!pieces || !pieces.length) return;

        // –†–∞–º–∫–∞ –ø–∞–∑–ª—É
        const pieceWidth = pieces[0].width;
        const pieceHeight = pieces[0].height;
        const cols = 3; // –±–æ –≤—Å—ñ –ø–∞–∑–ª–∏ 3x3
        const puzzleWidth = pieceWidth * cols;
        const puzzleHeight = pieceHeight * cols;
        const centerX = (this.canvas.width - puzzleWidth) / 2;
        const centerY = (this.canvas.height - puzzleHeight) / 2;
        
        // –¢—ñ–Ω—å —Ä–∞–º–∫–∏
        this.ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
        this.ctx.shadowBlur = 20;
        this.ctx.strokeStyle = 'gold';
        this.ctx.lineWidth = 4;
        this.ctx.strokeRect(centerX, centerY, puzzleWidth, puzzleHeight);
        this.ctx.shadowBlur = 0;
        
        // –®–º–∞—Ç–æ—á–∫–∏
        pieces.forEach(p => {
          if (p.img && p.img.complete) {
            this.ctx.drawImage(p.img, p.x, p.y, p.width, p.height);
          }
          
          // –ü—ñ–¥—Å–≤—ñ—á—É—î–º–æ –ø–µ—Ä–µ—Ç—è–≥—É–≤–∞–Ω–∏–π
          if (p === dragged) {
            this.ctx.strokeStyle = '#ff1493';
            this.ctx.lineWidth = 3;
            this.ctx.strokeRect(p.x, p.y, p.width, p.height);
          }
        });

        // –Ü–Ω—Å—Ç—Ä—É–∫—Ü—ñ—è
        this.ctx.fillStyle = 'white';
        this.ctx.font = 'bold 28px "Comic Sans MS"';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('üéÆ –ü–µ—Ä–µ—Ç—è–≥—É–π —à–º–∞—Ç–æ—á–∫–∏ –ø–∞–ª—å—á–∏–∫–æ–º! üéÆ', this.canvas.width/2, 80);
      }
    }

    // ================================================
    // 6. PuzzleEngine (–ª–æ–≥—ñ–∫–∞ + drag&drop)
    // ================================================
    class PuzzleEngine {
      constructor(config, renderer, bus) {
        this.config = config;
        this.renderer = renderer;
        this.bus = bus;
        this.pieces = [];
        this.dragged = null;
        this.offset = {x:0,y:0};
        this.init();
      }
      
      async init() {
        try {
          const img = await loadImage(this.config.image);
          this.createPieces(img);
        } catch(e) {
          console.warn('–ö–∞—Ä—Ç–∏–Ω–∫—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ ‚Üí —Å—Ç–≤–æ—Ä—é—î–º–æ –∫–æ–ª—å–æ—Ä–æ–≤–∏–π –ø–∞–∑–ª', e);
          this.createFallbackPieces();
        }
        this.bindEvents();
        this.render();
      }
      
      createPieces(img) {
        const {rows,cols} = this.config;
        const pieceWidth = Math.min(180, window.innerWidth/4);
        const pieceHeight = (img.height/img.width)*pieceWidth;
        
        const puzzleWidth = pieceWidth * cols;
        const puzzleHeight = pieceHeight * rows;
        const startX = (window.innerWidth - puzzleWidth)/2;
        const startY = (window.innerHeight - puzzleHeight)/2;

        const srcPieceWidth = img.width/cols;
        const srcPieceHeight = img.height/rows;

        for(let r=0;r<rows;r++) {
          for(let c=0;c<cols;c++) {
            const canvas = document.createElement('canvas');
            canvas.width = srcPieceWidth;
            canvas.height = srcPieceHeight;
            const ctx = canvas.getContext('2d');
            
            ctx.drawImage(
              img, 
              c*srcPieceWidth, r*srcPieceHeight, srcPieceWidth, srcPieceHeight,
              0, 0, srcPieceWidth, srcPieceHeight
            );
            
            const pieceImg = new Image();
            pieceImg.src = canvas.toDataURL();
            
            this.pieces.push({
              img: pieceImg,
              x: Math.random()*(window.innerWidth-pieceWidth),
              y: Math.random()*(window.innerHeight-pieceHeight),
              targetX: startX + c*pieceWidth,
              targetY: startY + r*pieceHeight,
              width: pieceWidth,
              height: pieceHeight,
              placed: false
            });
          }
        }
        this.shuffle();
      }
      
      createFallbackPieces() {
        const colors = ['#FF6B6B','#4ECDC4','#45B7D1','#96CEB4','#FFEAA7','#DDA0DD','#98D8C8','#F7DC6F','#BB8FCE'];
        const size = 120;
        const cols = 3, rows = 3;
        const puzzleWidth = size * cols;
        const puzzleHeight = size * rows;
        const startX = (window.innerWidth - puzzleWidth)/2;
        const startY = (window.innerHeight - puzzleHeight)/2;
        
        for(let i=0;i<9;i++) {
          const canvas = document.createElement('canvas');
          canvas.width = canvas.height = size;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = colors[i%colors.length];
          ctx.fillRect(0,0,size,size);
          ctx.fillStyle='white';
          ctx.font='bold 40px Comic Sans MS';
          ctx.textAlign='center';
          ctx.fillText(String(i+1), size/2, size/2+15);
          
          const row = Math.floor(i/3), col = i%3;
          const pieceImg = new Image();
          pieceImg.src = canvas.toDataURL();
          
          this.pieces.push({
            img: pieceImg,
            x: Math.random()*(window.innerWidth-size),
            y: Math.random()*(window.innerHeight-size),
            targetX: startX + col*size,
            targetY: startY + row*size,
            width: size,
            height: size,
            placed: false
          });
        }
      }
      
      shuffle() {
        for(let i=this.pieces.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [this.pieces[i],this.pieces[j]] = [this.pieces[j],this.pieces[i]];
        }
      }
      
      bindEvents() {
        const canvas = this.renderer.canvas;
        
        const startDrag = (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
          const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;
          
          for(let i=this.pieces.length-1;i>=0;i--){
            const p = this.pieces[i];
            if(x>=p.x && x<=p.x+p.width && y>=p.y && y<=p.y+p.height){
              this.dragged = p;
              this.offset = {x: x-p.x, y: y-p.y};
              // –ü–µ—Ä–µ–º—ñ—â—É—î–º–æ –Ω–∞ –ø–µ—Ä–µ–¥–Ω—ñ–π –ø–ª–∞–Ω
              this.pieces.splice(i,1);
              this.pieces.push(p);
              break;
            }
          }
        };
        
        const drag = (e) => {
          if(!this.dragged) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
          const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.left;
          
          this.dragged.x = x - this.offset.x;
          this.dragged.y = y - this.offset.y;
          this.render();
        };
        
        const endDrag = () => {
          if(!this.dragged) return;
          
          const dist = Math.hypot(
            this.dragged.x + this.dragged.width/2 - (this.dragged.targetX + this.dragged.width/2),
            this.dragged.y + this.dragged.height/2 - (this.dragged.targetY + this.dragged.height/2)
          );
          
          // –í–ò–ü–†–ê–í–õ–ï–ù–ê –ü–û–ú–ò–õ–ö–ê: –∑–∞–±—Ä–∞–Ω–∞ –∑–∞–π–≤–∞ —Ñ—ñ–≥—É—Ä–Ω–∞ –¥—É–∂–∫–∞
          if(dist < 50) {
            this.dragged.x = this.dragged.targetX;
            this.dragged.y = this.dragged.targetY;
            this.dragged.placed = true;
            
            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ –≤–µ—Å—å –ø–∞–∑–ª –∑—ñ–±—Ä–∞–Ω–æ
            if(this.pieces.every(p => p.placed)) {
              this.bus.emit('puzzle:solved');
            }
          }
          
          this.dragged = null;
          this.render();
        };
        
        canvas.addEventListener('mousedown', startDrag);
        canvas.addEventListener('touchstart', startDrag, {passive:false});
        canvas.addEventListener('mousemove', drag);
        canvas.addEventListener('touchmove', drag, {passive:false});
        canvas.addEventListener('mouseup', endDrag);
        canvas.addEventListener('touchend', endDrag);
        canvas.addEventListener('mouseleave', endDrag);
      }
      
      render() {
        this.renderer.draw(this.pieces, this.dragged);
      }
      
      destroy() {
        // –û—á–∏—â–∞—î–º–æ –ø–æ–¥—ñ—ó
        const canvas = this.renderer.canvas;
        const newCanvas = canvas.cloneNode(true);
        canvas.parentNode.replaceChild(newCanvas, canvas);
        this.pieces = [];
      }
    }

    // ================================================
    // 7. MindAR Controller
    // ================================================
    class MindARController {
      constructor() {
        this.sceneEl = document.querySelector('a-scene');
        this.system = null;
        this.isStarted = false;
      }
      
      async start() {
        try {
          // –í–ò–ü–†–ê–í–õ–ï–ù–ê –ü–û–ú–ò–õ–ö–ê: –ø—Ä–∞–≤–∏–ª—å–Ω–æ —á–µ–∫–∞—î–º–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Å—Ü–µ–Ω–∏
          return new Promise((resolve, reject) => {
            if (this.sceneEl.hasLoaded) {
              this.initializeAR().then(resolve).catch(reject);
            } else {
              this.sceneEl.addEventListener('loaded', () => {
                this.initializeAR().then(resolve).catch(reject);
              });
            }
          });
        } catch(error) {
          console.error('‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–ø—É—Å–∫—É AR:', error);
          alert('–ü–æ–º–∏–ª–∫–∞ –∑–∞–ø—É—Å–∫—É –∫–∞–º–µ—Ä–∏. –î–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏ —Ç–∞ –ø–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Å—Ç–æ—Ä—ñ–Ω–∫—É!');
        }
      }
      
      async initializeAR() {
        this.system = this.sceneEl.systems['mindar-image-system'];
        await this.system.start();
        this.isStarted = true;
        this.registerTargets();
        console.log('üéØ AR –∑–∞–ø—É—â–µ–Ω–æ —É—Å–ø—ñ—à–Ω–æ');
      }
      
      registerTargets() {
        PUZZLES.forEach(conf => {
          const entity = document.createElement('a-entity');
          entity.setAttribute('mindar-image-target', `targetIndex: ${conf.id}`);
          
          entity.addEventListener('targetFound', () => {
            console.log(`üéØ –ú–∞—Ä–∫–µ—Ä ${conf.id} –∑–Ω–∞–π–¥–µ–Ω–æ`);
            if (!currentPuzzle) {
              const renderer = new PuzzleRenderer(document.getElementById('puzzleCanvas'));
              currentPuzzle = new PuzzleEngine(conf, renderer, bus);
              screens.show('puzzle');
            }
          });
          
          this.sceneEl.appendChild(entity);
        });
      }
    }

    // ================================================
    // 8. –ó–ê–ü–£–°–ö –ì–†–ò
    // ================================================
    const ar = new MindARController();

    // –û–±—Ä–æ–±–∫–∞ –ø–æ–¥—ñ–π
    bus.on('puzzle:solved', () => {
      confettiManager.celebrate();
      
      setTimeout(() => {
        screens.show('win');
        setTimeout(() => {
          if (currentPuzzle) {
            currentPuzzle.destroy();
            currentPuzzle = null;
          }
          screens.show('hint');
        }, 3000);
      }, 2000);
    });

    // –ö–Ω–æ–ø–∫–∏
    document.getElementById('startBtn').addEventListener('click', () => {
      screens.show('hint');
      ar.start();
    });

    document.getElementById('closeBtn').addEventListener('click', () => {
      if (currentPuzzle) {
        currentPuzzle.destroy();
        currentPuzzle = null;
      }
      screens.show('hint');
    });

    // –ü–æ—á–∞—Ç–∫–æ–≤–∏–π –µ–∫—Ä–∞–Ω
    screens.show('start');
  </script>
</body>
</html>
