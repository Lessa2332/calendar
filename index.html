<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
  <title>–ú–∞–≥—ñ—á–Ω–∏–π –ø–∞–∑–ª –¥–ª—è –∑—ñ—Ä–æ—á–∫–∏</title>
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

  <style>
    body, html {
      margin: 0; 
      padding: 0; 
      height: 100%; 
      overflow: hidden; 
      background: #000; 
      font-family: 'Comic Sans MS', cursive, sans-serif;
      touch-action: none;
    }
    
    /* –ö–ê–ù–í–ê–° –ü–ê–ó–õ–£ - –ü–†–û–ó–û–†–ò–ô */
    #puzzleCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 100;
      display: none;
      cursor: grab;
      background: transparent !important;
    }
    
    #puzzleCanvas:active {
      cursor: grabbing;
    }
    
    /* –Ü–ù–¢–ï–†–§–ï–ô–° */
    #hint, #counter {
      position: fixed;
      padding: 16px 32px;
      border-radius: 50px;
      font-size: 24px;
      z-index: 999;
      color: #fff;
      box-shadow: 0 0 30px #ff1493;
      pointer-events: none;
    }
    
    #hint {
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #ff1493;
      text-align: center;
    }
    
    #counter {
      top: 80px;
      left: 20px;
      background: rgba(255, 20, 147, 0.8);
    }
    
    #win {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.97);
      color: gold;
      font-size: 80px;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 1000;
    }
    
    #win span {
      animation: bounce 1s infinite;
    }
    
    @keyframes bounce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.5); }
    }
    
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 20px;
      z-index: 1001;
    }
    
    #startButton {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #ff1493;
      color: white;
      border: none;
      padding: 20px 40px;
      border-radius: 50px;
      font-size: 24px;
      cursor: pointer;
      z-index: 1002;
      box-shadow: 0 0 30px #ff1493;
    }
    
    #closePuzzle {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 20, 147, 0.8);
      color: white;
      border: none;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      font-size: 30px;
      cursor: pointer;
      z-index: 101;
      display: none;
    }
    
    /* AR —Å—Ü–µ–Ω–∞ - –í–Ü–î–û–ë–†–ê–ñ–ê–Ñ –í–Ü–î–ï–û */
    a-scene {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    /* ‚úÖ –ü—Ä–∏—Ö–æ–≤—É—î–º–æ UI –µ–ª–µ–º–µ–Ω—Ç–∏ MindAR */
    .mindar-ui-overlay, 
    .mindar-ui-loading, 
    .mindar-ui-scanning {
      display: none !important;
    }
  </style>
</head>
<body>
  <!-- –ö–ê–ù–í–ê–° –î–õ–Ø –ü–ê–ó–õ–£ –ó –ü–†–û–ó–û–†–ò–ú –§–û–ù–û–ú -->
  <canvas id="puzzleCanvas"></canvas>
  <button id="closePuzzle">‚úï</button>
  
  <!-- –Ü–ù–¢–ï–†–§–ï–ô–° -->
  <div id="hint" style="display:none;">–ü–æ–∫–∞–∂–∏ –º–∞—Ä–∫–µ—Ä –∫–∞–º–µ—Ä—ñ ‚Üí —Ç–æ—Ä–∫–∞–π—Å—è –¥–ª—è –≥—Ä–∏!</div>
  <div id="counter" style="display:none;">–ó—ñ–±—Ä–∞–Ω–æ: 0 –∑ 12</div>
  <div id="win"><span>–£–†–ê–ê–ê!</span><br>–¢–∏ –Ω–∞–π–∫—Ä–∞—â–∏–π —á–∞—Ä—ñ–≤–Ω–∏–∫!</div>
  <div id="loading">–ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –º–∞–≥—ñ—é...</div>
  <button id="startButton">üéÆ –ü–û–ß–ê–¢–ò –ì–†–£ üéÆ</button>

  <!-- AR –°–¶–ï–ù–ê –ó –í–Ü–î–ï–û –§–û–ù–û–ú -->
  <a-scene
    embedded
    mindar-image="imageTargetSrc: calendar.mind; filterMinCF:0.0001; filterBeta:0.01; autoStart: false; showBackground: true;" 
    <!-- ‚úÖ –î–û–î–ê–ù–û: showBackground: true -->
    renderer="colorManagement: true; antialias: true"
    vr-mode-ui="enabled: false"
    device-orientation-permission-ui="enabled: false">

    <a-camera active="false"></a-camera>

    <!-- 12 –º–∞—Ä–∫–µ—Ä—ñ–≤ -->
    <a-entity id="target-0"  mindar-image-target="targetIndex: 0"></a-entity>
    <a-entity id="target-1"  mindar-image-target="targetIndex: 1"></a-entity>
    <a-entity id="target-2"  mindar-image-target="targetIndex: 2"></a-entity>
    <a-entity id="target-3"  mindar-image-target="targetIndex: 3"></a-entity>
    <a-entity id="target-4"  mindar-image-target="targetIndex: 4"></a-entity>
    <a-entity id="target-5"  mindar-image-target="targetIndex: 5"></a-entity>
    <a-entity id="target-6"  mindar-image-target="targetIndex: 6"></a-entity>
    <a-entity id="target-7"  mindar-image-target="targetIndex: 7"></a-entity>
    <a-entity id="target-8"  mindar-image-target="targetIndex: 8"></a-entity>
    <a-entity id="target-9"  mindar-image-target="targetIndex: 9"></a-entity>
    <a-entity id="target-10" mindar-image-target="targetIndex: 10"></a-entity>
    <a-entity id="target-11" mindar-image-target="targetIndex: 11"></a-entity>

  </a-scene>

  <audio id="yay" preload="auto"></audio>

  <script>
    // === –ì–õ–û–ë–ê–õ–¨–ù–Ü –ó–ú–Ü–ù–ù–Ü ===
    let activeTarget = null;
    let puzzleStates = {};
    let solvedCount = 0;
    const imageCache = {};
    
    // –ó–º—ñ–Ω–Ω—ñ –¥–ª—è canvas
    let canvas, ctx;
    let currentPuzzle = null;
    let draggedPiece = null;
    let dragOffset = { x: 0, y: 0 };
    let isDragging = false;

    // === –ö–ê–ù–í–ê–° –ü–ê–ó–õ–£ ===
    function initCanvas() {
      canvas = document.getElementById('puzzleCanvas');
      ctx = canvas.getContext('2d');
      
      canvas.style.background = 'transparent';
      
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      canvas.addEventListener('mousedown', startDrag);
      canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
      canvas.addEventListener('mousemove', drag);
      canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
      canvas.addEventListener('mouseup', endDrag);
      canvas.addEventListener('touchend', endDrag);
      canvas.addEventListener('mouseleave', endDrag);
    }

    function handleTouchStart(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('mousedown', {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      canvas.dispatchEvent(mouseEvent);
    }

    function handleTouchMove(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('mousemove', {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      canvas.dispatchEvent(mouseEvent);
    }

    function startDrag(e) {
      if (!currentPuzzle) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      for (let i = currentPuzzle.pieces.length - 1; i >= 0; i--) {
        const piece = currentPuzzle.pieces[i];
        if (piece.x <= x && x <= piece.x + piece.width &&
            piece.y <= y && y <= piece.y + piece.height) {
          
          draggedPiece = piece;
          isDragging = true;
          dragOffset.x = x - piece.x;
          dragOffset.y = y - piece.y;
          
          currentPuzzle.pieces.splice(i, 1);
          currentPuzzle.pieces.push(draggedPiece);
          break;
        }
      }
    }

    function drag(e) {
      if (!isDragging || !draggedPiece) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      draggedPiece.x = x - dragOffset.x;
      draggedPiece.y = y - dragOffset.y;
      
      drawPuzzle();
    }

    function endDrag() {
      if (!isDragging || !draggedPiece) return;
      
      isDragging = false;
      
      const targetX = draggedPiece.targetX;
      const targetY = draggedPiece.targetY;
      const distance = Math.hypot(
        draggedPiece.x + draggedPiece.width/2 - (targetX + draggedPiece.width/2),
        draggedPiece.y + draggedPiece.height/2 - (targetY + draggedPiece.height/2)
      );
      
      if (distance < 30) {
        draggedPiece.x = targetX;
        draggedPiece.y = targetY;
        draggedPiece.isInPlace = true;
        
        checkIfSolved();
      }
      
      draggedPiece = null;
      drawPuzzle();
    }

    function drawPuzzle() {
      if (!currentPuzzle) return;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const puzzleWidth = currentPuzzle.pieces[0].width * 3;
      const puzzleHeight = currentPuzzle.pieces[0].height * 3;
      const centerX = (canvas.width - puzzleWidth) / 2;
      const centerY = (canvas.height - puzzleHeight) / 2;
      
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 2;
      ctx.strokeRect(centerX, centerY, puzzleWidth, puzzleHeight);
      
      currentPuzzle.pieces.forEach(piece => {
        if (piece.image) {
          ctx.drawImage(piece.image, piece.x, piece.y, piece.width, piece.height);
        }
        
        if (piece === draggedPiece) {
          ctx.strokeStyle = '#ff1493';
          ctx.lineWidth = 3;
          ctx.strokeRect(piece.x, piece.y, piece.width, piece.height);
        }
      });
      
      ctx.fillStyle = 'white';
      ctx.font = '24px Comic Sans MS';
      ctx.textAlign = 'center';
      ctx.fillText('–ü–µ—Ä–µ—Ç—è–≥—É–π —à–º–∞—Ç–æ—á–∫–∏ –ø–∞–ª—å—Ü–µ–º!', canvas.width / 2, 50);
    }

    // === –°–¢–í–û–†–ï–ù–ù–Ø –ü–ê–ó–õ–£ ===
    async function createPuzzle(index) {
      if (puzzleStates[index]?.solved) return;
      
      const url = `images/${String(index+1).padStart(2,'0')}.jpg?t=${Date.now()}`;
      
      try {
        const img = await loadImage(url);
        const pieces = await createPuzzlePieces(img, index);
        
        currentPuzzle = {
          index: index,
          pieces: pieces,
          image: img
        };
        
        canvas.style.display = 'block';
        document.getElementById('closePuzzle').style.display = 'block';
        document.getElementById('hint').style.display = 'none';
        
        drawPuzzle();
        
        try {
          const audio = document.getElementById('yay');
          audio.src = `fon/${String(index+1).padStart(2,'0')}.mp3`;
          audio.volume = 0.7;
          audio.play().catch(e => console.log('üîá –ó–≤—É–∫ –Ω–µ –≤—ñ–¥—Ç–≤–æ—Ä–∏–≤—Å—è'));
        } catch(e) {}
        
      } catch (error) {
        console.error('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ø–∞–∑–ª—É:', error);
        createFallbackPuzzle(index);
      }
    }

    function loadImage(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error(`–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è`));
        img.src = url;
      });
    }

    function createPuzzlePieces(img, puzzleIndex) {
      return new Promise((resolve) => {
        const rows = 3, cols = 3;
        const pieces = [];
        
        const pieceWidth = Math.min(150, window.innerWidth / 4);
        const pieceHeight = (img.height / img.width) * pieceWidth;
        
        const puzzleWidth = pieceWidth * cols;
        const puzzleHeight = pieceHeight * rows;
        const startX = (window.innerWidth - puzzleWidth) / 2;
        const startY = (window.innerHeight - puzzleHeight) / 2;
        
        const srcPieceWidth = img.width / cols;
        const srcPieceHeight = img.height / rows;
        
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const canvas = document.createElement('canvas');
            canvas.width = srcPieceWidth;
            canvas.height = srcPieceHeight;
            const pieceCtx = canvas.getContext('2d');
            
            pieceCtx.drawImage(
              img,
              col * srcPieceWidth, row * srcPieceHeight, srcPieceWidth, srcPieceHeight,
              0, 0, srcPieceWidth, srcPieceHeight
            );
            
            const pieceImage = new Image();
            pieceImage.src = canvas.toDataURL();
            
            const targetX = startX + col * pieceWidth;
            const targetY = startY + row * pieceHeight;
            
            const startXPos = Math.random() * (window.innerWidth - pieceWidth);
            const startYPos = Math.random() * (window.innerHeight - pieceHeight);
            
            pieces.push({
              image: pieceImage,
              width: pieceWidth,
              height: pieceHeight,
              x: startXPos,
              y: startYPos,
              targetX: targetX,
              targetY: targetY,
              isInPlace: false
            });
          }
        }
        
        for (let i = pieces.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
        }
        
        resolve(pieces);
      });
    }

    function createFallbackPuzzle(index) {
      const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800', '#8800ff', '#0088ff'];
      const pieceWidth = 100;
      const pieceHeight = 100;
      const puzzleWidth = pieceWidth * 3;
      const puzzleHeight = pieceHeight * 3;
      const startX = (window.innerWidth - puzzleWidth) / 2;
      const startY = (window.innerHeight - puzzleHeight) / 2;
      
      const pieces = [];
      
      for (let i = 0; i < 9; i++) {
        const row = Math.floor(i / 3);
        const col = i % 3;
        
        const canvas = document.createElement('canvas');
        canvas.width = pieceWidth;
        canvas.height = pieceHeight;
        const pieceCtx = canvas.getContext('2d');
        pieceCtx.fillStyle = colors[i];
        pieceCtx.fillRect(0, 0, pieceWidth, pieceHeight);
        pieceCtx.fillStyle = 'white';
        pieceCtx.font = '20px Arial';
        pieceCtx.fillText(i + 1, 40, 55);
        
        const pieceImage = new Image();
        pieceImage.src = canvas.toDataURL();
        
        pieces.push({
          image: pieceImage,
          width: pieceWidth,
          height: pieceHeight,
          x: Math.random() * (window.innerWidth - pieceWidth),
          y: Math.random() * (window.innerHeight - pieceHeight),
          targetX: startX + col * pieceWidth,
          targetY: startY + row * pieceHeight,
          isInPlace: false
        });
      }
      
      currentPuzzle = {
        index: index,
        pieces: pieces
      };
      
      canvas.style.display = 'block';
      document.getElementById('closePuzzle').style.display = 'block';
      document.getElementById('hint').style.display = 'none';
      drawPuzzle();
    }

    function checkIfSolved() {
      if (!currentPuzzle) return;
      
      const allInPlace = currentPuzzle.pieces.every(piece => piece.isInPlace);
      
      if (allInPlace && !puzzleStates[currentPuzzle.index]?.solved) {
        puzzleStates[currentPuzzle.index] = { solved: true };
        solvedCount++;
        document.getElementById('counter').textContent = `–ó—ñ–±—Ä–∞–Ω–æ: ${solvedCount} –∑ 12`;
        
        confetti({
          particleCount: 150,
          spread: 70,
          origin: { y: 0.6 }
        });
        
        setTimeout(() => {
          closePuzzle();
          if (solvedCount === 12) {
            document.getElementById('win').style.display = 'flex';
            confetti({
              particleCount: 400,
              spread: 100,
              origin: { y: 0.6 }
            });
          }
        }, 2000);
      }
    }

    function closePuzzle() {
      canvas.style.display = 'none';
      document.getElementById('closePuzzle').style.display = 'none';
      document.getElementById('hint').style.display = 'block';
      currentPuzzle = null;
      draggedPiece = null;
      isDragging = false;
    }

    // === –ó–ê–ü–£–°–ö –ö–ê–ú–ï–†–ò ===
    async function startAR() {
      try {
        // ‚úÖ –°–ø–æ—á–∞—Ç–∫—É –æ—Ç—Ä–∏–º—É—î–º–æ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { facingMode: 'environment' } 
        });
        
        // ‚úÖ –ü–æ—Ç—ñ–º –∑–∞–ø—É—Å–∫–∞—î–º–æ MindAR
        const scene = document.querySelector('a-scene');
        const mindarSystem = scene.systems['mindar-image-system'];
        await mindarSystem.start();
        
        document.getElementById('startButton').style.display = 'none';
        document.getElementById('hint').style.display = 'block';
        document.getElementById('counter').style.display = 'block';
        document.getElementById('loading').style.display = 'none';
        
      } catch (err) {
        console.error('–ü–æ–º–∏–ª–∫–∞ –∫–∞–º–µ—Ä–∏:', err);
        alert('–î–æ–∑–≤–æ–ª—å –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏ –¥–ª—è –≥—Ä–∏! üì±');
      }
    }

    // === –Ü–ù–Ü–¶–Ü–ê–õ–Ü–ó–ê–¶–Ü–Ø ===
    document.querySelector('a-scene').addEventListener('loaded', () => {
      document.getElementById('loading').style.display = 'none';
      initCanvas();

      for (let i = 0; i < 12; i++) {
        const target = document.getElementById(`target-${i}`);
        target.addEventListener('targetFound', () => { 
          if (!currentPuzzle) {
            activeTarget = i;
            createPuzzle(i);
          }
        });
      }

      document.getElementById('startButton').addEventListener('click', startAR);
      
      document.getElementById('closePuzzle').addEventListener('click', closePuzzle);
    });
  </script>
</body>
</html>
