<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-eval' 'unsafe-inline' data: blob: https://aframe.io https://cdn.jsdelivr.net https://assets.mixkit.co; script-src 'self' 'unsafe-eval' 'unsafe-inline' https://aframe.io https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline';">
  <title>Магічний пазл для зірочки</title>
  
  <!-- A-Frame 1.7.0 + MindAR 2.2.1 -->
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@2.2.1/dist/mindar-image-aframe.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

  <style>
    body, html {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: 'Comic Sans MS', cursive, sans-serif;
    }
    #hint {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #ff1493;
      color: #fff;
      padding: 16px 32px;
      border-radius: 50px;
      font-size: 24px;
      z-index: 999;
      box-shadow: 0 0 30px #ff1493;
      text-align: center;
      max-width: 90%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #win {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.97);
      color: gold;
      font-size: 80px;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 1000;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    #win span {
      animation: bounce 1s infinite;
      font-size: clamp(40px, 10vw, 80px);
    }
    
    /* КЛЮЧОВИЙ CSS - гарантуємо видимість відеопотоку */
    a-scene canvas {
      background: transparent !important;
    }
    
    /* Стилі для AR-канвасу MindAR */
    .mindar-ui-overlay {
      background: transparent !important;
    }

    @keyframes bounce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.5); }
    }

    /* Адаптивність для дуже малих екранів */
    @media (max-width: 360px) {
      #hint {
        font-size: 18px;
        padding: 12px 24px;
      }
    }

    @media (max-height: 600px) {
      #hint {
        top: 10px;
      }
    }
  </style>
</head>
<body>

<div id="hint">Покажи маркер — і почнеться магія!</div>
<div id="win"><span>УРААА!</span><br>Ти найкращий чарівник!</div>

<a-scene
  embedded
  mindar-image="imageTargetSrc: ./calendar.mind; uiLoading: no; uiError: no; uiScanning: no; autoStart: false"
  renderer="colorManagement: true; alpha: true;"
  vr-mode-ui="enabled: false"
  device-orientation-permission-ui="enabled:false">

  <!-- Камера з прозорим фоном -->
  <a-camera background="transparent"></a-camera>

  <!-- 12 цілей (0–11) -->
  <a-entity id="targets-container"></a-entity>

</a-scene>

<audio id="yay" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3" preload="auto"></audio>

<script>
// Глобальні змінні для адаптивності
let currentPuzzle = null;
let resizeTimeout = null;

// Створюємо 12 цілей для marker 0–11
function createTargets() {
  const container = document.getElementById('targets-container');
  for (let i = 0; i < 12; i++) {
    const target = document.createElement('a-entity');
    target.setAttribute('mindar-image-target', `targetIndex: ${i}`);
    target.id = `target-${i}`;
    container.appendChild(target);
  }
}

// Запускаємо AR лише після кліку користувача
function startAR() {
  const scene = document.querySelector('a-scene');
  const mindarComponent = scene.systems['mindar-image-system'];
  if (mindarComponent && !mindarComponent.initialized) {
    mindarComponent.start().catch(err => {
      console.error('AR start failed:', err);
      document.getElementById('hint').textContent = '❌ Камера не доступна!';
    });
  }
  
  // Додатково встановлюємо прозорий фон для AR відео
  setTimeout(() => {
    const video = document.querySelector('video');
    if (video) {
      video.style.position = 'fixed';
      video.style.zIndex = '-1';
    }
    
    // Знаходимо і налаштовуємо canvas MindAR
    const canvases = document.querySelectorAll('canvas');
    canvases.forEach(canvas => {
      if (canvas.classList.contains('mindar-ui-overlay')) {
        canvas.style.background = 'transparent';
        canvas.style.zIndex = '1';
      }
    });
  }, 1000);
}

// Обробка знайденого маркера
let activeTargetIndex = null;
let clickHandler = null;

function onTargetFound(event) {
  const targetIndex = event.detail.targetIndex;
  if (activeTargetIndex === targetIndex) return;

  resetPuzzle();
  activeTargetIndex = targetIndex;
  setTimeout(() => createPuzzle(targetIndex), 500);
}

function onTargetLost(event) {
  const targetIndex = event.detail.targetIndex;
  if (activeTargetIndex === targetIndex) {
    resetPuzzle();
  }
}

function resetPuzzle() {
  if (clickHandler) {
    document.querySelector('a-scene').removeEventListener('click', clickHandler);
    clickHandler = null;
  }
  for (let i = 0; i < 12; i++) {
    const target = document.getElementById(`target-${i}`);
    if (target) target.innerHTML = '';
  }
  activeTargetIndex = null;
  currentPuzzle = null;
  document.getElementById('win').style.display = 'none';
}

// АДАПТИВНЕ СТВОРЕННЯ ПАЗЛУ
function createAdaptivePuzzle(targetIndex) {
  return new Promise((resolve) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = `./images/${String(targetIndex + 1).padStart(2, '0')}.jpg?t=${Date.now()}`;
    
    img.onload = () => {
      const rows = 3, cols = 3;
      
      // АДАПТИВНИЙ РОЗМІР ШМАТОЧКА
      const baseSize = Math.min(window.innerWidth, window.innerHeight);
      const pieceWidth = Math.max(100, Math.min(200, baseSize / 4.2));
      const pieceHeight = pieceWidth * (window.innerHeight / window.innerWidth > 1.8 ? 1.1 : 1);

      // Масштабування під співвідношення сторін
      const scaleX = window.innerWidth / 1080;
      const scaleY = window.innerHeight / 1920;
      const scale = Math.min(scaleX, scaleY, 1.5);

      const finalWidth = pieceWidth * scale;
      const finalHeight = pieceHeight * scale;

      const puzzleWidth = finalWidth * cols;
      const puzzleHeight = finalHeight * rows;

      // Безпечно центруємо з урахуванням safe-area
      const safeArea = {
        top: Math.max((window.innerHeight - puzzleHeight) * 0.5, 60),
        left: Math.max((window.innerWidth - puzzleWidth) * 0.5, 20)
      };

      const pieces = [];

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const pieceW = img.width / cols;
          const pieceH = img.height / rows;
          
          const canvas = document.createElement('canvas');
          canvas.width = pieceW;
          canvas.height = pieceH;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, col * pieceW, row * pieceH, pieceW, pieceH, 0, 0, pieceW, pieceH);

          const targetX = safeArea.left + col * finalWidth;
          const targetY = safeArea.top + row * finalHeight;

          // Розкид по всьому екрану, але не під UI і не за межі
          const randomX = Math.max(20, Math.min(window.innerWidth - finalWidth - 20, 
                                Math.random() * (window.innerWidth - finalWidth)));
          const randomY = Math.max(100, Math.min(window.innerHeight - finalHeight - 100, 
                                Math.random() * (window.innerHeight - finalHeight - 200) + 100));

          pieces.push({
            canvas: canvas,
            width: finalWidth,
            height: finalHeight,
            x: randomX,
            y: randomY,
            targetX: targetX,
            targetY: targetY,
            isInPlace: false,
            row: row,
            col: col
          });
        }
      }

      // Перемішуємо
      for (let i = pieces.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
      }

      resolve({
        pieces: pieces,
        index: targetIndex,
        safeArea: safeArea
      });
    };
    
    img.onerror = () => {
      console.error('Помилка завантаження зображення для пазлу', targetIndex);
      resolve(null);
    };
  });
}

async function createPuzzle(targetIndex) {
  const puzzleData = await createAdaptivePuzzle(targetIndex);
  if (!puzzleData) return;

  currentPuzzle = puzzleData;
  const pieces = puzzleData.pieces;
  const targetContainer = document.getElementById(`target-${targetIndex}`);

  // Очищаємо контейнер перед додаванням нових елементів
  targetContainer.innerHTML = '';

  // Додаємо шматочки пазлу як a-plane елементи
  pieces.forEach((piece, index) => {
    const plane = document.createElement('a-plane');
    plane.setAttribute('src', piece.canvas.toDataURL('image/jpeg', 0.92));
    plane.setAttribute('width', piece.width / 100);
    plane.setAttribute('height', piece.height / 100);
    plane.setAttribute('position', `${(piece.x - window.innerWidth/2) / 100} ${(window.innerHeight/2 - piece.y) / 100} 0.02`);
    plane.setAttribute('data-target-x', (piece.targetX - window.innerWidth/2) / 100);
    plane.setAttribute('data-target-y', (window.innerHeight/2 - piece.targetY) / 100);
    plane.setAttribute('data-index', index);
    plane.classList.add('piece');
    targetContainer.appendChild(plane);
  });

  // Обробник кліку
  clickHandler = (e) => {
    const pieceEl = e.detail.intersectedEl;
    if (!pieceEl || !pieceEl.classList.contains('piece')) return;

    const pieceIndex = parseInt(pieceEl.getAttribute('data-index'));
    const piece = pieces[pieceIndex];
    if (!piece || piece.isInPlace) return;

    // Знайти інший випадковий шматок, який не на місці
    const movablePieces = pieces.filter((p, idx) => !p.isInPlace && idx !== pieceIndex);
    if (movablePieces.length === 0) return;
    
    const otherPiece = movablePieces[Math.floor(Math.random() * movablePieces.length)];
    const otherIndex = pieces.indexOf(otherPiece);

    // Обміняти позиції
    const tempPos = pieceEl.getAttribute('position');
    pieceEl.setAttribute('position', pieces[otherIndex].el.getAttribute('position'));
    pieces[otherIndex].el.setAttribute('position', tempPos);

    // Оновити дані позицій
    const tempX = piece.x;
    const tempY = piece.y;
    piece.x = otherPiece.x;
    piece.y = otherPiece.y;
    otherPiece.x = tempX;
    otherPiece.y = tempY;

    // Перевірка перемоги
    const isSolved = pieces.every(p => {
      return Math.abs(p.x - p.targetX) < 10 && Math.abs(p.y - p.targetY) < 10;
    });

    if (isSolved) {
      document.getElementById('win').style.display = 'flex';
      document.getElementById('yay').play();
      confetti({ particleCount: 600, spread: 120, origin: { y: 0.6 } });

      document.querySelector('a-scene').removeEventListener('click', clickHandler);
      clickHandler = null;
    }
  };

  // Зберігаємо посилання на DOM елементи
  pieces.forEach((piece, index) => {
    piece.el = targetContainer.children[index];
  });

  document.querySelector('a-scene').addEventListener('click', clickHandler);
}

// АДАПТИВНИЙ РОЗМІР ПРИ ЗМІНІ РОЗМІРУ ВІКНА
function handleResize() {
  if (resizeTimeout) clearTimeout(resizeTimeout);
  
  resizeTimeout = setTimeout(() => {
    if (currentPuzzle && activeTargetIndex !== null) {
      // Перестворюємо пазл з новими розмірами
      resetPuzzle();
      setTimeout(() => createPuzzle(activeTargetIndex), 300);
    }
  }, 300);
}

// Ініціалізація
document.addEventListener('DOMContentLoaded', () => {
  createTargets();

  const scene = document.querySelector('a-scene');
  scene.addEventListener('targetFound', onTargetFound);
  scene.addEventListener('targetLost', onTargetLost);

  // Додаємо обробник зміни розміру вікна
  window.addEventListener('resize', handleResize);

  // Запускаємо AR при першому кліку на екран
  document.body.addEventListener('click', startAR, { once: true });
  
  // Додаткові заходи для прозорості
  setTimeout(() => {
    document.querySelectorAll('canvas').forEach(canvas => {
      canvas.style.background = 'transparent';
    });
    
    const video = document.querySelector('video');
    if (video) {
      video.style.objectFit = 'cover';
      video.style.zIndex = '-1';
    }
  }, 2000);
});
</script>
</body>
</html>
