<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>–ú–∞–≥—ñ—á–Ω–∏–π –ø–∞–∑–ª –¥–ª—è –∑—ñ—Ä–æ—á–∫–∏</title>

  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
  
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      /* ‚úÖ –ó–†–û–ë–ò–¢–ò —Ñ–æ–Ω –ø—Ä–æ–∑–æ—Ä–∏–º ‚Äî –≤—ñ–¥–µ–æ –∑ –∫–∞–º–µ—Ä–∏ –±—É–¥–µ –≤–∏–¥–Ω–æ */
      background: transparent !important;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      touch-action: none;
    }
    
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 100;
      display: none;
      cursor: grab;
      /* ‚úÖ –ü—Ä–æ–∑–æ—Ä–∏–π —Ñ–æ–Ω canvas ‚Äî —Ç—ñ–ª—å–∫–∏ –ø–∞–∑–ª–∏ –≤–∏–¥–Ω–æ */
      background: transparent;
    }
    
    canvas:active {
      cursor: grabbing;
    }
    
    .screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: white;
      z-index: 999;
      text-align: center;
      /* ‚úÖ –ü—Ä–æ–∑–æ—Ä–∏–π —Ñ–æ–Ω –µ–∫—Ä–∞–Ω—ñ–≤ */
      background: rgba(0, 0, 0, 0.6);
    }
    
    #startScreen {
      background: radial-gradient(circle at center, rgba(255, 20, 147, 0.8), transparent);
    }
    
    #loadingScreen, #hintScreen, #winScreen {
      background: rgba(0, 0, 0, 0.6);
    }
    
    #winScreen {
      color: gold;
    }
    
    #winScreen span {
      animation: bounce 1s infinite;
      margin-bottom: 20px;
    }
    
    @keyframes bounce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }
    
    button {
      background: #ff1493;
      color: white;
      border: none;
      padding: 20px 50px;
      border-radius: 50px;
      font-size: 30px;
      cursor: pointer;
      box-shadow: 0 0 40px #ff1493;
      transition: transform 0.2s;
    }
    
    button:hover {
      transform: scale(1.05);
    }
    
    #closeBtn {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      font-size: 30px;
      z-index: 101;
      display: none;
      background: #ff1493;
      color: white;
      border: none;
      border-radius: 50%;
    }
    
    .mindar-ui-overlay, .mindar-ui-loading, .mindar-ui-scanning {
      display: none !important;
    }

    /* –î–æ–¥–∞—Ç–∫–æ–≤–æ: –ø—Ä–∏—Ö–æ–≤—É—î–º–æ –≤—ñ–¥–µ–æ MindAR, —è–∫—â–æ –≤–æ–Ω–æ –Ω–µ –ø—Ä–æ–∑–æ—Ä–µ (—Ä–µ–¥–∫–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ) */
    .mindar-video {
      z-index: 1 !important;
    }
  </style>
</head>
<body>
  <canvas id="puzzleCanvas"></canvas>
  <button id="closeBtn">‚úï</button>

  <div id="startScreen" class="screen">
    <h1 style="font-size: 48px; margin-bottom: 30px;">‚ú® –ú–∞–≥—ñ—á–Ω–∏–π –ø–∞–∑–ª ‚ú®</h1>
    <button id="startBtn">üéÆ –ü–û–ß–ê–¢–ò –ú–ê–ì–Ü–Æ! üéÆ</button>
  </div>

  <div id="loadingScreen" class="screen">
    <div style="font-size: 32px; margin-bottom: 20px;">‚è≥ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è AR...</div>
    <div style="font-size: 24px; opacity: 0.8;">–ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞—á–µ–∫–∞–π—Ç–µ...</div>
  </div>

  <div id="hintScreen" class="screen">
    <div style="font-size: 32px; margin-bottom: 20px;">üîç –ü–æ–∫–∞–∂–∏ –º–∞—Ä–∫–µ—Ä –∫–∞–º–µ—Ä—ñ!</div>
    <div style="font-size: 24px; opacity: 0.8;">–ó–Ω–∞–π–¥–∏ —Å–ø–µ—Ü—ñ–∞–ª—å–Ω—ñ –∫–∞—Ä—Ç–∏–Ω–∫–∏ —Ç–∞ –∑–±–∏—Ä–∞–π –ø–∞–∑–ª–∏!</div>
  </div>

  <div id="winScreen" class="screen">
    <span>üéâ –£–†–ê–ê–ê! üéâ</span>
    <div style="font-size: 40px; margin-top: 20px;">–¢–∏ —á–∞—Ä—ñ–≤–Ω–∏–π –º–∞–π—Å—Ç–µ—Ä –ø–∞–∑–ª—ñ–≤! ‚ú®</div>
  </div>

  <!-- AR –°–¶–ï–ù–ê -->
  <a-scene 
    embedded 
    mindar-image="imageTargetSrc: calendar.mind; autoStart: false;"
    renderer="colorManagement: true; antialias: true"
    vr-mode-ui="enabled: false" 
    device-orientation-permission-ui="enabled: false"
    style="background: transparent !important;">
    
    <a-camera active="false"></a-camera>
  </a-scene>

  <script>
    // ================================================
    // –ö–û–ù–§–Ü–ì–£–†–ê–¶–Ü–Ø –ü–ê–ó–õ–Ü–í
    // ================================================
    const PUZZLES = Array.from({length: 12}, (_, i) => ({
      id: i,
      image: `images/${String(i + 1).padStart(2, '0')}.jpg`,
      rows: 3,
      cols: 3
    }));

    let currentPuzzle = null;

    // ================================================
    // –ú–ï–ù–ï–î–ñ–ï–† –ï–ö–†–ê–ù–Ü–í
    // ================================================
    class ScreenManager {
      constructor() {
        this.screens = {
          start: document.getElementById('startScreen'),
          loading: document.getElementById('loadingScreen'),
          hint: document.getElementById('hintScreen'),
          win: document.getElementById('winScreen')
        };
        this.closeBtn = document.getElementById('closeBtn');
        this.canvas = document.getElementById('puzzleCanvas');
      }

      show(screenName) {
        Object.values(this.screens).forEach(screen => {
          if (screen) screen.style.display = 'none';
        });
        this.canvas.style.display = 'none';
        this.closeBtn.style.display = 'none';

        switch(screenName) {
          case 'start':
            this.screens.start.style.display = 'flex';
            break;
          case 'loading':
            this.screens.loading.style.display = 'flex';
            break;
          case 'hint':
            this.screens.hint.style.display = 'flex';
            break;
          case 'puzzle':
            this.canvas.style.display = 'block';
            this.closeBtn.style.display = 'block';
            break;
          case 'win':
            this.screens.win.style.display = 'flex';
            break;
        }
      }
    }

    const screens = new ScreenManager();

    // ================================================
    // –ú–ï–ù–ï–î–ñ–ï–† –ö–û–ù–§–ï–¢–Ü
    // ================================================
    class ConfettiManager {
      celebrate() {
        confetti({
          particleCount: 200,
          spread: 100,
          origin: { y: 0.6 }
        });

        setTimeout(() => {
          confetti({
            particleCount: 150,
            angle: 60,
            spread: 80,
            origin: { x: 0 }
          });
        }, 500);

        setTimeout(() => {
          confetti({
            particleCount: 150,
            angle: 120,
            spread: 80,
            origin: { x: 1 }
          });
        }, 1000);
      }
    }

    const confettiManager = new ConfettiManager();

    // ================================================
    // –£–¢–ò–õ–Ü–¢–ê –ó–ê–í–ê–ù–¢–ê–ñ–ï–ù–ù–Ø –ó–û–ë–†–ê–ñ–ï–ù–¨
    // ================================================
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error(`–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏: ${src}`));
        img.src = src;
      });
    }

    // ================================================
    // –†–ï–ù–î–ï–†–ï–† –ü–ê–ó–õ–£ (—Ç–µ–ø–µ—Ä –±–µ–∑ —Ñ–æ–Ω—É!)
    // ================================================
    class PuzzleRenderer {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d', { alpha: true }); // ‚úÖ –ü—Ä–æ–∑–æ—Ä–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
        this.setupCanvas();
      }

      setupCanvas() {
        const resize = () => {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
        };
        
        resize();
        window.addEventListener('resize', resize);
      }

      render(pieces, draggedPiece = null) {
        // ‚úÖ –û—á–∏—â–∞—î–º–æ –∑ –ø—Ä–æ–∑–æ—Ä—ñ—Å—Ç—é
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        if (!pieces || pieces.length === 0) return;

        const pieceWidth = pieces[0].width;
        const pieceHeight = pieces[0].height;
        const cols = 3;
        const puzzleWidth = pieceWidth * cols;
        const puzzleHeight = pieceHeight * cols;
        const centerX = (this.canvas.width - puzzleWidth) / 2;
        const centerY = (this.canvas.height - puzzleHeight) / 2;
        
        // ‚úÖ –ú–∞–ª—é—î–º–æ –ª–∏—à–µ —Ä–∞–º–∫—É –ø–∞–∑–ª—É (–±–µ–∑ —Ñ–æ–Ω—É)
        this.ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
        this.ctx.shadowBlur = 20;
        this.ctx.strokeStyle = 'gold';
        this.ctx.lineWidth = 4;
        this.ctx.strokeRect(centerX, centerY, puzzleWidth, puzzleHeight);
        this.ctx.shadowBlur = 0;
        
        // –ú–∞–ª—é—î–º–æ —à–º–∞—Ç–æ—á–∫–∏
        pieces.forEach(piece => {
          if (piece.image && piece.image.complete) {
            this.ctx.drawImage(piece.image, piece.x, piece.y, piece.width, piece.height);
          }
          
          if (piece === draggedPiece) {
            this.ctx.strokeStyle = '#ff1493';
            this.ctx.lineWidth = 3;
            this.ctx.strokeRect(piece.x, piece.y, piece.width, piece.height);
          }
        });

        // –Ü–Ω—Å—Ç—Ä—É–∫—Ü—ñ—è (–ø—Ä–æ–∑–æ—Ä–∞)
        this.ctx.fillStyle = 'white';
        this.ctx.font = 'bold 28px "Comic Sans MS"';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('üéÆ –ü–µ—Ä–µ—Ç—è–≥—É–π —à–º–∞—Ç–æ—á–∫–∏ –ø–∞–ª—å—á–∏–∫–æ–º! üéÆ', this.canvas.width / 2, 80);
      }
    }

    // (–†–µ—à—Ç–∞ –∫–ª–∞—Å—ñ–≤ PuzzleEngine, MindARController ‚Äî –±–µ–∑ –∑–º—ñ–Ω)

    class PuzzleEngine {
      constructor(config, renderer) {
        this.config = config;
        this.renderer = renderer;
        this.pieces = [];
        this.draggedPiece = null;
        this.dragOffset = { x: 0, y: 0 };
        this.init();
      }

      async init() {
        try {
          const img = await loadImage(this.config.image);
          await this.createPieces(img);
        } catch (error) {
          console.warn('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è, —Å—Ç–≤–æ—Ä—é—î–º–æ –∫–æ–ª—å–æ—Ä–æ–≤–∏–π –ø–∞–∑–ª:', error);
          this.createFallbackPieces();
        }
        this.bindEvents();
        this.render();
      }

      async createPieces(img) {
        const { rows, cols } = this.config;
        const pieceWidth = Math.min(180, window.innerWidth / 4);
        const pieceHeight = (img.height / img.width) * pieceWidth;
        
        const puzzleWidth = pieceWidth * cols;
        const puzzleHeight = pieceHeight * rows;
        const startX = (window.innerWidth - puzzleWidth) / 2;
        const startY = (window.innerHeight - puzzleHeight) / 2;

        const srcPieceWidth = img.width / cols;
        const srcPieceHeight = img.height / rows;

        const piecePromises = [];

        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            piecePromises.push(this.createPiece(
              img, row, col, srcPieceWidth, srcPieceHeight,
              pieceWidth, pieceHeight, startX, startY
            ));
          }
        }

        this.pieces = await Promise.all(piecePromises);
        this.shufflePieces();
      }

      createPiece(img, row, col, srcWidth, srcHeight, pieceWidth, pieceHeight, startX, startY) {
        return new Promise((resolve) => {
          const canvas = document.createElement('canvas');
          canvas.width = srcWidth;
          canvas.height = srcHeight;
          const ctx = canvas.getContext('2d');
          
          ctx.drawImage(
            img,
            col * srcWidth, row * srcHeight, srcWidth, srcHeight,
            0, 0, srcWidth, srcHeight
          );
          
          const pieceImage = new Image();
          pieceImage.onload = () => {
            resolve({
              image: pieceImage,
              width: pieceWidth,
              height: pieceHeight,
              x: Math.random() * (window.innerWidth - pieceWidth),
              y: Math.random() * (window.innerHeight - pieceHeight),
              targetX: startX + col * pieceWidth,
              targetY: startY + row * pieceHeight,
              isInPlace: false
            });
          };
          pieceImage.src = canvas.toDataURL();
        });
      }

      createFallbackPieces() {
        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE'];
        const size = 120;
        const cols = 3, rows = 3;
        const puzzleWidth = size * cols;
        const puzzleHeight = size * rows;
        const startX = (window.innerWidth - puzzleWidth) / 2;
        const startY = (window.innerHeight - puzzleHeight) / 2;
        
        this.pieces = [];

        for (let i = 0; i < 9; i++) {
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext('2d');
          
          ctx.fillStyle = colors[i % colors.length];
          ctx.fillRect(0, 0, size, size);
          
          ctx.fillStyle = 'white';
          ctx.font = 'bold 40px "Comic Sans MS"';
          ctx.textAlign = 'center';
          ctx.fillText((i + 1).toString(), size / 2, size / 2 + 15);
          
          const pieceImage = new Image();
          pieceImage.src = canvas.toDataURL();
          
          const row = Math.floor(i / 3);
          const col = i % 3;
          
          this.pieces.push({
            image: pieceImage,
            width: size,
            height: size,
            x: Math.random() * (window.innerWidth - size),
            y: Math.random() * (window.innerHeight - size),
            targetX: startX + col * size,
            targetY: startY + row * size,
            isInPlace: false
          });
        }
      }

      shufflePieces() {
        for (let i = this.pieces.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [this.pieces[i], this.pieces[j]] = [this.pieces[j], this.pieces[i]];
        }
      }

      bindEvents() {
        const canvas = this.renderer.canvas;
        
        const startDrag = (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
          const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;
          
          for (let i = this.pieces.length - 1; i >= 0; i--) {
            const piece = this.pieces[i];
            if (x >= piece.x && x <= piece.x + piece.width &&
                y >= piece.y && y <= piece.y + piece.height) {
              
              this.draggedPiece = piece;
              this.dragOffset.x = x - piece.x;
              this.dragOffset.y = y - piece.y;
              
              this.pieces.splice(i, 1);
              this.pieces.push(piece);
              break;
            }
          }
        };

        const drag = (e) => {
          if (!this.draggedPiece) return;
          
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
          const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;
          
          this.draggedPiece.x = x - this.dragOffset.x;
          this.draggedPiece.y = y - this.dragOffset.y;
          
          this.render();
        };

        const endDrag = () => {
          if (!this.draggedPiece) return;
          
          const targetX = this.draggedPiece.targetX;
          const targetY = this.draggedPiece.targetY;
          const distance = Math.hypot(
            this.draggedPiece.x + this.draggedPiece.width / 2 - (targetX + this.draggedPiece.width / 2),
            this.draggedPiece.y + this.draggedPiece.height / 2 - (targetY + this.draggedPiece.height / 2)
          );
          
          if (distance < 40) {
            this.draggedPiece.x = targetX;
            this.draggedPiece.y = targetY;
            this.draggedPiece.isInPlace = true;
            this.checkCompletion();
          }
          
          this.draggedPiece = null;
          this.render();
        };

        canvas.addEventListener('mousedown', startDrag);
        canvas.addEventListener('touchstart', startDrag, { passive: false });
        canvas.addEventListener('mousemove', drag);
        canvas.addEventListener('touchmove', drag, { passive: false });
        canvas.addEventListener('mouseup', endDrag);
        canvas.addEventListener('touchend', endDrag);
        canvas.addEventListener('mouseleave', endDrag);
      }

      checkCompletion() {
        const allInPlace = this.pieces.every(piece => piece.isInPlace);
        if (allInPlace) {
          confettiManager.celebrate();
          setTimeout(() => {
            screens.show('win');
            setTimeout(() => {
              this.destroy();
              currentPuzzle = null;
              screens.show('hint');
            }, 3000);
          }, 2000);
        }
      }

      render() {
        this.renderer.render(this.pieces, this.draggedPiece);
      }

      destroy() {
        const canvas = this.renderer.canvas;
        const newCanvas = canvas.cloneNode(true);
        canvas.parentNode.replaceChild(newCanvas, canvas);
        this.pieces = [];
      }
    }

    class MindARController {
      constructor() {
        this.sceneEl = document.querySelector('a-scene');
        this.isInitialized = false;
        this.camera = this.sceneEl.querySelector('a-camera');
      }

      initialize() {
        if (this.isInitialized) return;
        
        if (this.camera) {
          this.camera.setAttribute('active', 'true');
        }

        PUZZLES.forEach(config => {
          const entity = document.createElement('a-entity');
          entity.setAttribute('mindar-image-target', `targetIndex: ${config.id}`);
          
          entity.addEventListener('targetFound', () => {
            console.log(`üéØ –ú–∞—Ä–∫–µ—Ä ${config.id} –∑–Ω–∞–π–¥–µ–Ω–æ!`);
            if (!currentPuzzle) {
              const renderer = new PuzzleRenderer(document.getElementById('puzzleCanvas'));
              currentPuzzle = new PuzzleEngine(config, renderer);
              screens.show('puzzle');
            }
          });

          this.sceneEl.appendChild(entity);
        });
        
        this.isInitialized = true;
        console.log('üéØ AR —Å–∏—Å—Ç–µ–º–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞');
      }
    }

    const arController = new MindARController();

    document.getElementById('startBtn').addEventListener('click', async () => {
      try {
        // ‚úÖ –Ø–≤–Ω–æ –∑–∞–ø–∏—Ç—É—î–º–æ –∑–∞–¥–Ω—é –∫–∞–º–µ—Ä—É (—Ö–æ—á–∞ MindAR —Ä–æ–±–∏—Ç—å —Ü–µ —Å–∞–º)
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { ideal: "environment" } // –∑–∞–¥–Ω—è –∫–∞–º–µ—Ä–∞
          }
        });
        // –ó—É–ø–∏–Ω—è—î–º–æ –ø–æ—Ç—ñ–∫ ‚Äî MindAR –∑–∞–ø—É—Å—Ç–∏—Ç—å —Å–≤—ñ–π
        stream.getTracks().forEach(track => track.stop());

        screens.show('loading');
        arController.initialize();

        const scene = document.querySelector('a-scene');
        scene.addEventListener('loaded', () => {
          console.log('‚úÖ A-Frame —Å—Ü–µ–Ω–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∞');
          screens.show('hint');
        });

        scene.addEventListener('mindar-image-target-found', (e) => {
          console.log('üéØ Target found:', e.detail.targetIndex);
        });

        scene.addEventListener('mindar-image-target-lost', (e) => {
          console.log('‚ùå Target lost:', e.detail.targetIndex);
        });

      } catch (err) {
        alert("–ë—É–¥—å –ª–∞—Å–∫–∞, –¥–∞–π—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏, —â–æ–± –ø–æ—á–∞—Ç–∏ –≥—Ä—É!");
        console.error("–î–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏ –≤—ñ–¥–º–æ–≤–ª–µ–Ω–æ:", err);
        screens.show('start');
      }
    });

    document.getElementById('closeBtn').addEventListener('click', () => {
      if (currentPuzzle) {
        currentPuzzle.destroy();
        currentPuzzle = null;
      }
      screens.show('hint');
    });

    document.addEventListener('DOMContentLoaded', () => {
      screens.show('start');
    });
  </script>
</body>
</html>
