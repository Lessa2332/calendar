<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Calendar Puzzle | ÐšÐ°Ð»ÐµÐ½Ð´Ð°Ñ€ AR ÐŸÐ°Ð·Ð»Ð¸</title>
    
    <!-- MindAR Ñ‚Ð° Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.3/dist/mindar-image.prod.js"></script>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.3/dist/mindar-image-aframe.prod.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #6e8efb, #a777e3);
        }

        /* Language Switcher */
        .language-switcher {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 20px;
            z-index: 100;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            border: 2px solid #ff9e7d;
            display: flex;
            gap: 10px;
        }

        .lang-btn {
            background: none;
            border: none;
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 15px;
            transition: all 0.3s;
            font-family: inherit;
            font-weight: bold;
        }

        .lang-btn.active {
            background: #4ecdc4;
            color: white;
        }

        /* AR Container */
        #ar-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* UI Overlay */
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #instructions, #completion-message {
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            pointer-events: auto;
            border: 4px solid #ff9e7d;
            margin: 15px;
        }

        #instructions h2, #completion-message h2 {
            color: #ff6b6b;
            margin-bottom: 15px;
            font-size: 28px;
            text-shadow: 2px 2px 0px rgba(255, 255, 255, 0.5);
        }

        #instructions p, #completion-message p {
            margin-bottom: 20px;
            color: #333;
            line-height: 1.5;
            font-size: 18px;
        }

        button {
            background: linear-gradient(to bottom, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 30px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
            pointer-events: auto;
            box-shadow: 0 4px 0 #2a7c74;
            font-weight: bold;
            margin: 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #2a7c74;
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 0 #2a7c74;
        }

        .hidden {
            display: none !important;
        }

        /* Puzzle Counter */
        .puzzle-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: bold;
            color: #ff6b6b;
            pointer-events: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            border: 2px solid #ff9e7d;
            z-index: 100;
        }

        /* Marker Hint */
        .marker-hint {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            font-size: 16px;
            pointer-events: none;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
            background: rgba(0,0,0,0.4);
            padding: 10px;
            border-radius: 10px;
            margin: 0 20px;
            z-index: 100;
        }

        /* Victory Animation */
        @keyframes star-pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        .star-particle {
            animation: star-pulse 1s infinite;
        }

        /* Loading Screen */
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #6e8efb, #a777e3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255,255,255,0.3);
            border-top: 5px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Image Processing Info */
        .processing-info {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            font-size: 14px;
            pointer-events: none;
            background: rgba(0,0,0,0.6);
            padding: 8px;
            margin: 0 20px;
            border-radius: 10px;
            z-index: 100;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #instructions, #completion-message {
                margin: 10px;
                padding: 20px;
            }
            
            #instructions h2, #completion-message h2 {
                font-size: 24px;
            }
            
            #instructions p, #completion-message p {
                font-size: 16px;
            }
            
            button {
                padding: 10px 20px;
                font-size: 16px;
            }
            
            .language-switcher {
                top: 10px;
                left: 10px;
                padding: 8px 12px;
            }
            
            .puzzle-counter {
                top: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loader"></div>
        <h2 data-i18n="loading.title">Loading AR Experience...</h2>
        <p data-i18n="loading.description">Preparing puzzle pieces from your images</p>
        <div class="processing-info" id="processing-info">Loading images...</div>
    </div>

    <!-- Language Switcher -->
    <div class="language-switcher">
        <button class="lang-btn active" data-lang="en">EN</button>
        <button class="lang-btn" data-lang="uk">UA</button>
    </div>

    <!-- AR Container -->
    <div id="ar-container">
        <a-scene 
            mindar-image="imageTargetSrc: https://raw.githubusercontent.com/Lessa2332/your-calendar/main/calendarmind; autoStart: false; uiLoading: no; uiScanning: no; uiError: no;"
            embedded
            color-space="sRGB"
            renderer="colorManagement: true; physicallyCorrectLights"
            vr-mode-ui="enabled: false"
            device-orientation-permission-ui="enabled: false">
            
            <!-- Camera -->
            <a-entity camera></a-entity>

            <!-- Puzzle Pieces will be dynamically added here -->
            <a-entity id="puzzle-targets-container"></a-entity>

            <!-- Static puzzle board -->
            <a-entity id="puzzle-board" position="0 0 -1.5" visible="false">
                <a-plane id="board" color="#f0f0f0" width="2.5" height="2.5" position="0 0 0"></a-plane>
                <a-entity id="grid-container"></a-entity>
            </a-entity>

            <!-- Victory effects -->
            <a-entity id="victory-effects" visible="false"></a-entity>
        </a-scene>
    </div>

    <!-- UI Overlay -->
    <div id="ui-overlay">
        <div id="instructions">
            <h2 data-i18n="instructions.title">AR Calendar Puzzle Adventure! ðŸ§©</h2>
            <p data-i18n="instructions.description1">Point your device at calendar images to reveal puzzle pieces!</p>
            <p data-i18n="instructions.description2">Drag pieces to the board to complete the puzzle and see a magic star! âœ¨</p>
            <button id="start-btn" data-i18n="instructions.startButton">Start AR Experience</button>
        </div>
        <div id="completion-message" class="hidden">
            <h2 data-i18n="completion.title">Congratulations! ðŸŽ‰</h2>
            <p data-i18n="completion.description">You completed the calendar puzzle! Amazing!</p>
            <button id="restart-btn" data-i18n="completion.restartButton">Play Again</button>
        </div>
    </div>

    <!-- Puzzle Counter -->
    <div class="puzzle-counter">
        <span data-i18n="counter.text">Pieces:</span> <span id="piece-count">0</span>/9
    </div>

    <!-- Marker Hint -->
    <div class="marker-hint" data-i18n="marker.hint">
        Point camera at calendar images to see puzzle pieces
    </div>

    <!-- Hidden Canvas for Image Processing -->
    <canvas id="image-processor" style="display: none;"></canvas>

    <script>
        // Multi-language support
        const translations = {
            en: {
                "loading.title": "Loading AR Experience...",
                "loading.description": "Preparing puzzle pieces from your images",
                "instructions.title": "AR Calendar Puzzle Adventure! ðŸ§©",
                "instructions.description1": "Point your device at calendar images to reveal puzzle pieces!",
                "instructions.description2": "Drag pieces to the board to complete the puzzle and see a magic star! âœ¨",
                "instructions.startButton": "Start AR Experience",
                "completion.title": "Congratulations! ðŸŽ‰",
                "completion.description": "You completed the calendar puzzle! Amazing!",
                "completion.restartButton": "Play Again",
                "counter.text": "Pieces:",
                "marker.hint": "Point camera at calendar images to see puzzle pieces"
            },
            uk: {
                "loading.title": "Ð—Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð½Ñ AR...",
                "loading.description": "Ð“Ð¾Ñ‚ÑƒÑ”Ð¼Ð¾ Ð¿Ð°Ð·Ð»Ð¸ Ð· Ð²Ð°ÑˆÐ¸Ñ… Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½ÑŒ",
                "instructions.title": "AR ÐšÐ°Ð»ÐµÐ½Ð´Ð°Ñ€ ÐŸÐ°Ð·Ð»Ð¸! ðŸ§©",
                "instructions.description1": "ÐÐ°Ð²ÐµÐ´Ñ–Ñ‚ÑŒ Ð¿Ñ€Ð¸ÑÑ‚Ñ€Ñ–Ð¹ Ð½Ð° Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð½Ñ ÐºÐ°Ð»ÐµÐ½Ð´Ð°Ñ€Ñ, Ñ‰Ð¾Ð± Ð¿Ð¾Ð±Ð°Ñ‡Ð¸Ñ‚Ð¸ Ð¿Ð°Ð·Ð»Ð¸!",
                "instructions.description2": "ÐŸÐµÑ€ÐµÑ‚ÑÐ³ÑƒÐ¹Ñ‚Ðµ Ð¿Ð°Ð·Ð»Ð¸ Ð½Ð° Ð´Ð¾ÑˆÐºÑƒ, Ñ‰Ð¾Ð± ÑÐºÐ»Ð°ÑÑ‚Ð¸ ÐºÐ°Ñ€Ñ‚Ð¸Ð½ÐºÑƒ Ñ‚Ð° Ð¿Ð¾Ð±Ð°Ñ‡Ð¸Ñ‚Ð¸ Ð¼Ð°Ð³Ñ–Ñ‡Ð½Ñƒ Ð·Ñ–Ñ€Ð¾Ñ‡ÐºÑƒ! âœ¨",
                "instructions.startButton": "ÐŸÐ¾Ñ‡Ð°Ñ‚Ð¸ AR Ð“Ñ€Ñƒ",
                "completion.title": "Ð’Ñ–Ñ‚Ð°Ñ”Ð¼Ð¾! ðŸŽ‰",
                "completion.description": "Ð’Ð¸ ÑÐºÐ»Ð°Ð»Ð¸ ÐºÐ°Ð»ÐµÐ½Ð´Ð°Ñ€-Ð¿Ð°Ð·Ð»! Ð§ÑƒÐ´Ð¾Ð²Ð¾!",
                "completion.restartButton": "Ð“Ñ€Ð°Ñ‚Ð¸ Ð·Ð½Ð¾Ð²Ñƒ",
                "counter.text": "ÐŸÐ°Ð·Ð»Ñ–Ð²:",
                "marker.hint": "ÐÐ°Ð²ÐµÐ´Ñ–Ñ‚ÑŒ ÐºÐ°Ð¼ÐµÑ€Ñƒ Ð½Ð° Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð½Ñ ÐºÐ°Ð»ÐµÐ½Ð´Ð°Ñ€Ñ, Ñ‰Ð¾Ð± Ð¿Ð¾Ð±Ð°Ñ‡Ð¸Ñ‚Ð¸ Ð¿Ð°Ð·Ð»Ð¸"
            }
        };

        class ImageSplitter {
            constructor() {
                this.canvas = document.getElementById('image-processor');
                this.ctx = this.canvas.getContext('2d');
                this.pieceCache = new Map();
            }

            async splitImage(imageUrl, rows = 3, cols = 3) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    
                    img.onload = () => {
                        try {
                            const pieceWidth = img.width / cols;
                            const pieceHeight = img.height / rows;
                            const pieces = [];

                            this.canvas.width = pieceWidth;
                            this.canvas.height = pieceHeight;

                            for (let row = 0; row < rows; row++) {
                                for (let col = 0; col < cols; col++) {
                                    this.ctx.clearRect(0, 0, pieceWidth, pieceHeight);
                                    
                                    this.ctx.drawImage(
                                        img,
                                        col * pieceWidth, row * pieceHeight,
                                        pieceWidth, pieceHeight,
                                        0, 0,
                                        pieceWidth, pieceHeight
                                    );

                                    const dataURL = this.canvas.toDataURL('image/jpeg', 0.9);
                                    pieces.push({
                                        dataURL: dataURL,
                                        row: row,
                                        col: col,
                                        index: row * cols + col
                                    });
                                }
                            }

                            resolve(pieces);
                        } catch (error) {
                            reject(error);
                        }
                    };

                    img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = imageUrl;
                });
            }
        }

        class ARPuzzleGame {
            constructor() {
                this.scene = document.querySelector('a-scene');
                this.isDragging = false;
                this.currentPiece = null;
                this.placedPieces = [];
                this.gridSize = 3;
                this.gridSlots = [];
                this.puzzleCompleted = false;
                this.imageSplitter = new ImageSplitter();
                this.puzzlePieces = [];
                
                this.init();
            }

            async init() {
                this.setupLocalization();
                await this.loadAndProcessImages();
                this.setupEventListeners();
                this.createGrid();
                
                this.scene.addEventListener('loaded', () => {
                    setTimeout(() => {
                        document.getElementById('loading-screen').style.display = 'none';
                    }, 1000);
                });
            }

            async loadAndProcessImages() {
                const imageUrls = [];
                
                // Generate URLs for images 01-12 from your repo
                for (let i = 1; i <= 12; i++) {
                    const num = i.toString().padStart(2, '0');
                    imageUrls.push(`https://raw.githubusercontent.com/Lessa2332/your-calendar/main/images/${num}.jpg`);
                }

                let processedCount = 0;
                
                for (let i = 0; i < Math.min(imageUrls.length, 9); i++) {
                    try {
                        document.getElementById('processing-info').textContent = 
                            `Processing image ${i + 1} of ${Math.min(imageUrls.length, 9)}...`;
                        
                        const pieces = await this.imageSplitter.splitImage(imageUrls[i]);
                        this.puzzlePieces.push({
                            originalImage: imageUrls[i],
                            pieces: pieces,
                            targetIndex: i
                        });
                        
                        processedCount++;
                        document.getElementById('processing-info').textContent = 
                            `Processed ${processedCount} images...`;
                        
                        // Add slight delay to avoid overwhelming the browser
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (error) {
                        console.error(`Failed to process image ${i + 1}:`, error);
                    }
                }

                this.createPuzzleEntities();
            }

            createPuzzleEntities() {
                const container = document.getElementById('puzzle-targets-container');
                
                this.puzzlePieces.forEach((puzzle, puzzleIndex) => {
                    // Use only the first piece from each image for demonstration
                    // In a full implementation, you might want to use all pieces
                    const piece = puzzle.pieces[0];
                    
                    const targetEntity = document.createElement('a-entity');
                    targetEntity.setAttribute('mindar-image-target', `targetIndex: ${puzzleIndex}`);
                    
                    const pieceEntity = document.createElement('a-entity');
                    pieceEntity.setAttribute('class', 'puzzle-piece');
                    pieceEntity.setAttribute('data-piece-id', puzzleIndex + 1);
                    pieceEntity.setAttribute('data-original-image', puzzleIndex + 1);
                    pieceEntity.setAttribute('data-piece-index', 0);
                    pieceEntity.setAttribute('scale', '0.5 0.5 0.5');
                    
                    const plane = document.createElement('a-plane');
                    plane.setAttribute('width', '0.8');
                    plane.setAttribute('height', '0.8');
                    plane.setAttribute('position', '0 0 0.001');
                    plane.setAttribute('src', piece.dataURL);
                    plane.setAttribute('transparent', 'true');
                    
                    pieceEntity.appendChild(plane);
                    targetEntity.appendChild(pieceEntity);
                    container.appendChild(targetEntity);
                });

                document.getElementById('processing-info').textContent = 
                    'Puzzle pieces ready! Click "Start AR Experience" to begin.';
            }

            setupLocalization() {
                this.currentLang = 'en';
                const buttons = document.querySelectorAll('.lang-btn');
                
                buttons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const lang = e.target.dataset.lang;
                        this.switchLanguage(lang);
                        buttons.forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                    });
                });
                
                this.loadLanguage('en');
            }

            switchLanguage(lang) {
                this.currentLang = lang;
                this.loadLanguage(lang);
            }

            loadLanguage(lang) {
                const elements = document.querySelectorAll('[data-i18n]');
                elements.forEach(element => {
                    const key = element.getAttribute('data-i18n');
                    if (translations[lang] && translations[lang][key]) {
                        element.textContent = translations[lang][key];
                    }
                });
            }

            setupEventListeners() {
                document.getElementById('start-btn').addEventListener('click', () => {
                    this.startAR();
                });

                document.getElementById('restart-btn').addEventListener('click', () => {
                    this.restartGame();
                });

                this.setupDragAndDrop();
            }

            startAR() {
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('puzzle-board').setAttribute('visible', 'true');
                
                const mindarScene = this.scene.querySelector('[mindar-image]').components['mindar-image'];
                mindarScene.start();
                
                this.gridSlots.forEach(slot => {
                    slot.element.setAttribute('visible', 'true');
                });
            }

            createGrid() {
                const gridContainer = document.getElementById('grid-container');
                const slotSize = 0.8;
                
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const x = (col - 1) * slotSize;
                        const y = (1 - row) * slotSize;
                        
                        const slot = document.createElement('a-entity');
                        slot.setAttribute('class', 'grid-slot');
                        slot.setAttribute('data-row', row);
                        slot.setAttribute('data-col', col);
                        slot.setAttribute('position', `${x} ${y} 0.01`);
                        slot.setAttribute('geometry', `primitive: plane; width: ${slotSize * 0.9}; height: ${slotSize * 0.9}`);
                        slot.setAttribute('material', 'color: rgba(200, 200, 200, 0.3); transparent: true; opacity: 0.5');
                        slot.setAttribute('visible', 'false');
                        
                        gridContainer.appendChild(slot);
                        this.gridSlots.push({
                            element: slot,
                            row: row,
                            col: col,
                            occupied: false
                        });
                    }
                }
            }

            setupDragAndDrop() {
                this.scene.addEventListener('mousedown', (e) => this.onInteractionStart(e));
                this.scene.addEventListener('touchstart', (e) => this.onInteractionStart(e));
                
                this.scene.addEventListener('mousemove', (e) => this.onInteractionMove(e));
                this.scene.addEventListener('touchmove', (e) => this.onInteractionMove(e));
                
                this.scene.addEventListener('mouseup', (e) => this.onInteractionEnd(e));
                this.scene.addEventListener('touchend', (e) => this.onInteractionEnd(e));
            }

            onInteractionStart(event) {
                if (this.puzzleCompleted) return;
                
                const intersected = event.detail && event.detail.intersectedEl;
                if (intersected && (intersected.classList.contains('puzzle-piece') || 
                    intersected.parentElement.classList.contains('puzzle-piece'))) {
                    
                    this.isDragging = true;
                    this.currentPiece = intersected.classList.contains('puzzle-piece') ? 
                        intersected : intersected.parentElement;
                    
                    this.currentPiece.setAttribute('animation', {
                        property: 'scale',
                        to: '0.6 0.6 0.6',
                        dur: 200
                    });
                    
                    event.preventDefault();
                }
            }

            onInteractionMove(event) {
                if (!this.isDragging || !this.currentPiece) return;
                
                const camera = document.querySelector('[camera]');
                const cameraPosition = camera.getAttribute('position');
                
                const x = cameraPosition.x;
                const y = cameraPosition.y;
                const z = cameraPosition.z - 1;
                
                this.currentPiece.setAttribute('position', {x, y, z});
                event.preventDefault();
            }

            onInteractionEnd(event) {
                if (!this.isDragging || !this.currentPiece) return;
                
                this.isDragging = false;
                this.snapToGrid(this.currentPiece);
                this.currentPiece = null;
                event.preventDefault();
            }

            snapToGrid(piece) {
                const piecePosition = piece.getAttribute('position');
                const board = document.getElementById('puzzle-board');
                const boardPosition = board.getAttribute('position');
                
                let closestSlot = null;
                let minDistance = Infinity;
                
                for (const slot of this.gridSlots) {
                    if (slot.occupied) continue;
                    
                    const slotPosition = slot.element.getAttribute('position');
                    const worldSlotPosition = {
                        x: boardPosition.x + slotPosition.x,
                        y: boardPosition.y + slotPosition.y,
                        z: boardPosition.z + slotPosition.z
                    };
                    
                    const distance = Math.sqrt(
                        Math.pow(piecePosition.x - worldSlotPosition.x, 2) + 
                        Math.pow(piecePosition.y - worldSlotPosition.y, 2)
                    );
                    
                    if (distance < minDistance && distance < 0.5) {
                        minDistance = distance;
                        closestSlot = slot;
                    }
                }
                
                if (closestSlot) {
                    const slotPosition = closestSlot.element.getAttribute('position');
                    const targetPosition = {
                        x: boardPosition.x + slotPosition.x,
                        y: boardPosition.y + slotPosition.y,
                        z: boardPosition.z + 0.02
                    };
                    
                    piece.setAttribute('animation', {
                        property: 'position',
                        to: `${targetPosition.x} ${targetPosition.y} ${targetPosition.z}`,
                        dur: 300
                    });
                    
                    piece.setAttribute('animation__scale', {
                        property: 'scale',
                        to: '0.4 0.4 0.4',
                        dur: 300
                    });
                    
                    closestSlot.occupied = true;
                    closestSlot.pieceId = piece.getAttribute('data-piece-id');
                    
                    this.placedPieces.push({
                        pieceId: piece.getAttribute('data-piece-id'),
                        row: closestSlot.row,
                        col: closestSlot.col
                    });
                    
                    document.getElementById('piece-count').textContent = this.placedPieces.length;
                    this.checkPuzzleCompletion();
                } else {
                    piece.setAttribute('animation', {
                        property: 'scale',
                        to: '0.5 0.5 0.5',
                        dur: 300
                    });
                }
            }

            checkPuzzleCompletion() {
                if (this.placedPieces.length === this.gridSize * this.gridSize) {
                    this.puzzleCompleted = true;
                    this.showVictoryAnimation();
                }
            }

            showVictoryAnimation() {
                const victoryEffects = document.getElementById('victory-effects');
                victoryEffects.setAttribute('visible', 'true');
                
                for (let i = 0; i < 15; i++) {
                    const star = document.createElement('a-entity');
                    star.setAttribute('class', 'star-particle');
                    star.setAttribute('geometry', 'primitive: octahedron');
                    star.setAttribute('material', 'color: yellow');
                    star.setAttribute('scale', '0.1 0.1 0.1');
                    
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 0.3 + Math.random() * 0.7;
                    const height = -0.5 + Math.random() * 1;
                    
                    star.setAttribute('position', {
                        x: Math.cos(angle) * radius,
                        y: height,
                        z: Math.sin(angle) * radius - 1.5
                    });
                    
                    star.setAttribute('animation', {
                        property: 'position',
                        to: `${Math.cos(angle) * 2} ${height + 1.5} ${Math.sin(angle) * 2 - 1.5}`,
                        dur: 2000 + Math.random() * 1000,
                        easing: 'easeOutQuad'
                    });
                    
                    victoryEffects.appendChild(star);
                }
                
                document.getElementById('completion-message').classList.remove('hidden');
            }

            restartGame() {
                this.placedPieces = [];
                this.puzzleCompleted = false;
                document.getElementById('piece-count').textContent = '0';
                
                document.getElementById('victory-effects').setAttribute('visible', 'false');
                document.getElementById('completion-message').classList.add('hidden');
                
                const victoryEffects = document.getElementById('victory-effects');
                while (victoryEffects.children.length > 0) {
                    victoryEffects.removeChild(victoryEffects.firstChild);
                }
                
                this.gridSlots.forEach(slot => {
                    slot.occupied = false;
                    delete slot.pieceId;
                });
                
                const pieces = document.querySelectorAll('.puzzle-piece');
                pieces.forEach(piece => {
                    piece.setAttribute('scale', '0.5 0.5 0.5');
                });
                
                document.getElementById('instructions').classList.remove('hidden');
            }
        }

        // Initialize the game when everything is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.puzzleGame = new ARPuzzleGame();
        });
    </script>
</body>
</html>
