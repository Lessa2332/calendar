<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-eval' 'unsafe-inline' data: blob: https://aframe.io https://cdn.jsdelivr.net https://assets.mixkit.co https://raw.githubusercontent.com; script-src 'self' 'unsafe-eval' 'unsafe-inline' https://aframe.io https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline';">
  <title>–ú–∞–≥—ñ—á–Ω–∏–π –ø–∞–∑–ª –¥–ª—è –∑—ñ—Ä–æ—á–∫–∏</title>
  
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@2.2.1/dist/mindar-image-aframe.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

  <style>
    body, html {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: 'Comic Sans MS', cursive, sans-serif;
    }

    /* === üîë –ö–†–ò–¢–ò–ß–ù–ò–ô –§–Ü–ö–° –ü–†–û–ó–û–†–û–°–¢–Ü === */
    video {
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      width: 100% !important;
      height: 100% !important;
      object-fit: cover !important;
      z-index: 0 !important;
      background: transparent !important;
    }

    a-scene canvas {
      background: transparent !important;
      z-index: 1 !important;
    }

    #hint {
      position: fixed;
      top: max(20px, env(safe-area-inset-top, 20px));
      left: 50%;
      transform: translateX(-50%);
      background: #ff1493;
      color: #fff;
      padding: 16px 32px;
      border-radius: 50px;
      font-size: 24px;
      z-index: 999;
      box-shadow: 0 0 30px #ff1493;
      text-align: center;
      max-width: 90%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #win {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.97);
      color: gold;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 1000;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }

    #win span {
      animation: bounce 1s infinite;
      font-size: clamp(40px, 10vw, 80px);
    }

    @keyframes bounce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.5); }
    }

    @media (max-width: 360px) {
      #hint { font-size: 18px; padding: 12px 24px; }
    }

    @media (max-height: 600px) {
      #hint { top: 10px; }
    }
  </style>
</head>
<body>

<div id="hint">–ü–æ–∫–∞–∂–∏ –º–∞—Ä–∫–µ—Ä ‚Äî —ñ –ø–æ—á–Ω–µ—Ç—å—Å—è –º–∞–≥—ñ—è!</div>
<div id="win"><span>–£–†–ê–ê–ê!</span><br>–¢–∏ –Ω–∞–π–∫—Ä–∞—â–∏–π —á–∞—Ä—ñ–≤–Ω–∏–∫!</div>

<a-scene
  embedded
  mindar-image="imageTargetSrc: ./calendar.mind; uiLoading: no; uiError: no; uiScanning: no; autoStart: false"
  renderer="colorManagement: true; alpha: true;"
  vr-mode-ui="enabled: false"
  device-orientation-permission-ui="enabled: false">

  <!-- –ö–∞–º–µ—Ä–∞: –Ω–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ –¥–æ–¥–∞–≤–∞—Ç–∏ background ‚Äî –≤—ñ–Ω –Ω–µ –ø—Ä–∞—Ü—é—î -->
  <a-camera></a-camera>

  <a-entity id="targets-container"></a-entity>
</a-scene>

<audio id="yay" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3" preload="auto"></audio>

<script>
let currentPuzzle = null;
let resizeTimeout = null;

function createTargets() {
  const container = document.getElementById('targets-container');
  for (let i = 0; i < 12; i++) {
    const target = document.createElement('a-entity');
    target.setAttribute('mindar-image-target', `targetIndex: ${i}`);
    target.id = `target-${i}`;
    container.appendChild(target);
  }
}

// üîë –ó–∞–ø—É—Å–∫ –∑ getUserMedia —É –º–µ–∂–∞—Ö –∫–ª—ñ–∫—É
async function startAR() {
  try {
    // –¶–µ –≥–∞—Ä–∞–Ω—Ç—É—î –¥–æ–∑–≤—ñ–ª —É Safari —Ç–∞ Chrome
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'environment' }
    });
    window._tempCameraStream = stream;

    const scene = document.querySelector('a-scene');
    const mindar = scene.systems['mindar-image-system'];
    if (mindar && !mindar.initialized) {
      await mindar.start();
    }

    document.getElementById('hint').textContent = '–ó–Ω–∞–π–¥–∏ –º–∞—Ä–∫–µ—Ä —É –∫–∞–ª–µ–Ω–¥–∞—Ä—ñ!';
  } catch (err) {
    console.error('AR start failed:', err);
    document.getElementById('hint').textContent = '‚ùå –î–æ–∑–≤–æ–ª—å –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏ —É –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è—Ö!';
  }
}

let activeTargetIndex = null;
let clickHandler = null;

function onTargetFound(event) {
  const targetIndex = event.detail.targetIndex;
  if (activeTargetIndex === targetIndex) return;
  resetPuzzle();
  activeTargetIndex = targetIndex;
  setTimeout(() => createPuzzle(targetIndex), 500);
}

function onTargetLost(event) {
  if (activeTargetIndex === event.detail.targetIndex) {
    resetPuzzle();
  }
}

function resetPuzzle() {
  if (clickHandler) {
    document.querySelector('a-scene').removeEventListener('click', clickHandler);
    clickHandler = null;
  }
  for (let i = 0; i < 12; i++) {
    const el = document.getElementById(`target-${i}`);
    if (el) el.innerHTML = '';
  }
  activeTargetIndex = null;
  currentPuzzle = null;
  document.getElementById('win').style.display = 'none';
}

async function createAdaptivePuzzle(targetIndex) {
  return new Promise((resolve) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = `./images/${String(targetIndex + 1).padStart(2, '0')}.jpg?t=${Date.now()}`;
    
    img.onload = () => {
      const rows = 3, cols = 3;
      const baseSize = Math.min(window.innerWidth, window.innerHeight);
      const pieceSize = Math.max(100, Math.min(200, baseSize / 4.2));
      const scale = Math.min(window.innerWidth / 1080, window.innerHeight / 1920, 1.5);
      const finalSize = pieceSize * scale;

      const puzzleW = finalSize * cols;
      const puzzleH = finalSize * rows;
      const safeTop = Math.max((window.innerHeight - puzzleH) * 0.5, 60);
      const safeLeft = Math.max((window.innerWidth - puzzleW) * 0.5, 20);

      const pieces = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const canvas = document.createElement('canvas');
          canvas.width = canvas.height = 400;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, c * img.width/cols, r * img.height/rows, img.width/cols, img.height/rows, 0, 0, 400, 400);

          const targetX = safeLeft + c * finalSize;
          const targetY = safeTop + r * finalSize;

          const randX = Math.max(20, Math.min(window.innerWidth - finalSize - 20, Math.random() * (window.innerWidth - finalSize)));
          const randY = Math.max(100, Math.min(window.innerHeight - finalSize - 100, Math.random() * (window.innerHeight - finalSize - 200) + 100));

          pieces.push({ canvas, size: finalSize, x: randX, y: randY, targetX, targetY, correct: false });
        }
      }

      // Shuffle
      for (let i = pieces.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
      }

      resolve({ pieces, index: targetIndex });
    };

    img.onerror = () => resolve(null);
  });
}

async function createPuzzle(targetIndex) {
  const data = await createAdaptivePuzzle(targetIndex);
  if (!data) return;

  currentPuzzle = data;
  const { pieces } = data;
  const container = document.getElementById(`target-${targetIndex}`);
  container.innerHTML = '';

  pieces.forEach((p, i) => {
    const plane = document.createElement('a-plane');
    plane.setAttribute('src', p.canvas.toDataURL('image/jpeg', 0.92));
    plane.setAttribute('width', p.size / 100);
    plane.setAttribute('height', p.size / 100);
    plane.setAttribute('position', `${(p.x - window.innerWidth/2)/100} ${(window.innerHeight/2 - p.y)/100} 0.02`);
    plane.setAttribute('data-idx', i);
    plane.classList.add('piece');
    container.appendChild(plane);
    p.el = plane;
  });

  clickHandler = (e) => {
    const el = e.detail?.intersectedEl;
    if (!el || !el.classList.contains('piece')) return;
    const idx = +el.getAttribute('data-idx');
    const clicked = pieces[idx];
    if (clicked.correct) return;

    const others = pieces.filter((p, i) => !p.correct && i !== idx);
    if (others.length === 0) return;

    const other = others[Math.floor(Math.random() * others.length)];
    const tempPos = el.getAttribute('position');
    el.setAttribute('position', other.el.getAttribute('position'));
    other.el.setAttribute('position', tempPos);

    [clicked.x, other.x] = [other.x, clicked.x];
    [clicked.y, other.y] = [other.y, clicked.y];

    const allCorrect = pieces.every(p => {
      const dx = Math.abs(p.x - p.targetX);
      const dy = Math.abs(p.y - p.targetY);
      return dx < 15 && dy < 15;
    });

    if (allCorrect) {
      document.getElementById('win').style.display = 'flex';
      document.getElementById('yay').play().catch(() => {});
      confetti({ particleCount: 600, spread: 120, origin: { y: 0.6 } });
      document.querySelector('a-scene').removeEventListener('click', clickHandler);
      clickHandler = null;
    }
  };

  document.querySelector('a-scene').addEventListener('click', clickHandler);
}

function handleResize() {
  if (resizeTimeout) clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    if (currentPuzzle && activeTargetIndex !== null) {
      resetPuzzle();
      setTimeout(() => createPuzzle(activeTargetIndex), 300);
    }
  }, 300);
}

document.addEventListener('DOMContentLoaded', () => {
  createTargets();
  const scene = document.querySelector('a-scene');
  scene.addEventListener('targetFound', onTargetFound);
  scene.addEventListener('targetLost', onTargetLost);
  window.addEventListener('resize', handleResize);

  // üîë –ó–∞–ø—É—Å–∫ —Ç—ñ–ª—å–∫–∏ –ø—ñ—Å–ª—è –∫–ª—ñ–∫—É –∑ getUserMedia
  document.body.addEventListener('click', startAR, { once: true });
});
</script>
</body>
</html>
