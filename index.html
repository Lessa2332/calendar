<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://aframe.io https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob: https://assets.mixkit.co; media-src 'self' https://assets.mixkit.co; connect-src 'self' https://aframe.io https://cdn.jsdelivr.net https://assets.mixkit.co;">
  <title>–ú–∞–≥—ñ—á–Ω–∏–π –ø–∞–∑–ª –¥–ª—è –∑—ñ—Ä–æ—á–∫–∏</title>
  
  <!-- A-Frame 1.7.0 + MindAR 2.2.1 -->
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@2.2.1/dist/mindar-image-aframe.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body, html {
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      touch-action: none;
    }

    #hint {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #ff1493, #ff69b4);
      color: #fff;
      padding: 16px 32px;
      border-radius: 50px;
      font-size: clamp(16px, 4vw, 24px);
      z-index: 999;
      box-shadow: 0 0 30px rgba(255, 20, 147, 0.7);
      text-align: center;
      max-width: 90%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border: 2px solid #fff;
      animation: pulse 2s infinite;
    }

    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 24px;
      z-index: 1001;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px 40px;
      border-radius: 20px;
      display: none;
    }

    #win {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      color: gold;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 1000;
      text-align: center;
      padding: 20px;
    }

    #win span {
      animation: bounce 1s infinite;
      font-size: clamp(40px, 10vw, 80px);
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
      margin-bottom: 20px;
    }

    #win p {
      font-size: clamp(20px, 5vw, 32px);
      color: #ff69b4;
    }

    /* –ì–∞—Ä–∞–Ω—Ç—É—î–º–æ –≤–∏–¥–∏–º—ñ—Å—Ç—å –≤—ñ–¥–µ–æ–ø–æ—Ç–æ–∫—É */
    a-scene canvas {
      background: transparent !important;
    }

    .mindar-ui-overlay {
      background: transparent !important;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }

    @keyframes bounce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }

    /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ñ—Å—Ç—å */
    @media (max-width: 480px) {
      #hint {
        padding: 12px 24px;
        font-size: 16px;
      }
    }

    @media (max-height: 600px) {
      #hint {
        top: 10px;
      }
    }
  </style>
</head>
<body>

<div id="hint">üëÜ –ù–∞—Ç–∏—Å–Ω–∏ –Ω–∞ –µ–∫—Ä–∞–Ω, —â–æ–± –ø–æ—á–∞—Ç–∏ –≥—Ä—É!</div>
<div id="loading">üîÑ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div>
<div id="win">
  <span>üéâ –£–†–ê–ê–ê!</span>
  <p>–¢–∏ –Ω–∞–π–∫—Ä–∞—â–∏–π —á–∞—Ä—ñ–≤–Ω–∏–∫! üßô‚Äç‚ôÄÔ∏è</p>
</div>

<a-scene
  embedded
  mindar-image="imageTargetSrc: ./calendar.mind; uiLoading: no; uiError: no; uiScanning: no; autoStart: false"
  renderer="colorManagement: true; alpha: true; precision: medium;"
  vr-mode-ui="enabled: false"
  device-orientation-permission-ui="enabled:false">

  <a-camera active="true" background="transparent" cursor="rayOrigin: mouse"></a-camera>

  <a-entity id="targets-container"></a-entity>

</a-scene>

<audio id="yay" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3" preload="auto"></audio>

<script>
// –í–∏–Ω–æ—Å–∏–º–æ –≤–µ—Å—å JavaScript –≤ –æ–∫—Ä–µ–º–∏–π —Ñ–∞–π–ª –∞–±–æ –∑–∞–ª–∏—à–∞—î–º–æ inline –∑ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–º–∏ –¥–æ–∑–≤–æ–ª–∞–º–∏
document.addEventListener('DOMContentLoaded', function() {
  'use strict';
  
  class MagicPuzzleGame {
    constructor() {
      this.currentPuzzle = null;
      this.activeTargetIndex = null;
      this.clickHandler = null;
      this.resizeTimeout = null;
      this.isInitialized = false;
      
      this.init();
    }

    init() {
      this.createTargets();
      this.setupEventListeners();
      this.setupVideoObserver();
    }

    createTargets() {
      const container = document.getElementById('targets-container');
      if (!container) return;
      
      for (let i = 0; i < 12; i++) {
        const target = document.createElement('a-entity');
        target.setAttribute('mindar-image-target', 'targetIndex: ' + i);
        target.id = 'target-' + i;
        container.appendChild(target);
      }
    }

    setupEventListeners() {
      const scene = document.querySelector('a-scene');
      if (!scene) return;
      
      scene.addEventListener('targetFound', (event) => this.onTargetFound(event));
      scene.addEventListener('targetLost', (event) => this.onTargetLost(event));
      
      window.addEventListener('resize', () => this.handleResize());
      
      // –ó–∞–ø—É—Å–∫ AR –ø—Ä–∏ –ø–µ—Ä—à–æ–º—É –∫–ª—ñ–∫—É
      document.body.addEventListener('click', () => this.startAR(), { once: true });
    }

    setupVideoObserver() {
      const observer = new MutationObserver((mutations) => {
        const video = document.querySelector('video');
        if (video) {
          this.setupVideoStyles(video);
          observer.disconnect();
        }
      });
      
      observer.observe(document.body, { childList: true, subtree: true });
    }

    setupVideoStyles(video) {
      video.style.position = 'fixed';
      video.style.zIndex = '-1';
      video.style.objectFit = 'cover';
      video.style.width = '100%';
      video.style.height = '100%';
    }

    async startAR() {
      this.showLoading('–ó–∞–ø—É—Å–∫–∞—î–º–æ –∫–∞–º–µ—Ä—É...');
      
      try {
        const scene = document.querySelector('a-scene');
        const mindarComponent = scene?.systems['mindar-image-system'];
        
        if (mindarComponent && !mindarComponent.initialized) {
          await mindarComponent.start();
          this.updateHint('–ó–Ω–∞–π–¥–∏ –º–∞—Ä–∫–µ—Ä —É –∫–∞–ª–µ–Ω–¥–∞—Ä—ñ! üìñ');
        }
      } catch (error) {
        console.error('AR start failed:', error);
        this.updateHint('‚ùå –ü–æ–º–∏–ª–∫–∞ –∫–∞–º–µ—Ä–∏! –î–æ–∑–≤–æ–ª—å –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏.');
      } finally {
        this.hideLoading();
      }
    }

    onTargetFound(event) {
      const targetIndex = event.detail.targetIndex;
      if (this.activeTargetIndex === targetIndex) return;

      this.resetPuzzle();
      this.activeTargetIndex = targetIndex;
      
      setTimeout(() => {
        this.createPuzzle(targetIndex);
      }, 500);
    }

    onTargetLost(event) {
      const targetIndex = event.detail.targetIndex;
      if (this.activeTargetIndex === targetIndex) {
        this.resetPuzzle();
      }
    }

    resetPuzzle() {
      if (this.clickHandler) {
        const scene = document.querySelector('a-scene');
        if (scene) {
          scene.removeEventListener('click', this.clickHandler);
        }
        this.clickHandler = null;
      }

      for (let i = 0; i < 12; i++) {
        const target = document.getElementById('target-' + i);
        if (target) target.innerHTML = '';
      }

      this.activeTargetIndex = null;
      this.currentPuzzle = null;
      this.hideWinScreen();
    }

    async createPuzzle(targetIndex) {
      this.showLoading('–°—Ç–≤–æ—Ä—é—î–º–æ –ø–∞–∑–ª...');

      try {
        const puzzleData = await this.createAdaptivePuzzle(targetIndex);
        if (!puzzleData) {
          throw new Error('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –ø–∞–∑–ª');
        }

        this.currentPuzzle = puzzleData;
        this.setupPuzzleElements(targetIndex, puzzleData.pieces);
        this.setupClickHandler(puzzleData.pieces);
        
        this.updateHint('–ö–ª–∞—Ü–∞–π –Ω–∞ —à–º–∞—Ç–æ—á–∫–∏, —â–æ–± –∑—ñ–±—Ä–∞—Ç–∏ –ø–∞–∑–ª! üß©');

      } catch (error) {
        console.error('Puzzle creation failed:', error);
        this.updateHint('‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ø–∞–∑–ª—É');
      } finally {
        this.hideLoading();
      }
    }

    createAdaptivePuzzle(targetIndex) {
      return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        
        // –§–æ—Ä–º–∞—Ç—É—î–º–æ –Ω–æ–º–µ—Ä –∑ –≤–µ–¥—É—á–∏–º–∏ –Ω—É–ª—è–º–∏
        const imageNumber = String(targetIndex + 1).padStart(2, '0');
        img.src = './images/' + imageNumber + '.jpg?t=' + Date.now();
        
        img.onload = () => {
          const rows = 3, cols = 3;
          
          // –ê–¥–∞–ø—Ç–∏–≤–Ω—ñ —Ä–æ–∑–º—ñ—Ä–∏
          const screenWidth = window.innerWidth;
          const screenHeight = window.innerHeight;
          const isPortrait = screenHeight > screenWidth;
          
          const baseSize = Math.min(screenWidth, screenHeight);
          const pieceSize = Math.max(80, Math.min(180, baseSize / (isPortrait ? 3.5 : 4.5)));
          
          const scale = Math.min(screenWidth / 1080, screenHeight / 1920, 1.3);
          const finalSize = pieceSize * scale;

          const puzzleWidth = finalSize * cols;
          const puzzleHeight = finalSize * rows;

          // –ë–µ–∑–ø–µ—á–Ω–∞ –æ–±–ª–∞—Å—Ç—å –∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É
          const safeArea = {
            top: Math.max((screenHeight - puzzleHeight) * 0.4, 80),
            left: Math.max((screenWidth - puzzleWidth) * 0.5, 20)
          };

          const pieces = [];
          const pieceW = img.width / cols;
          const pieceH = img.height / rows;

          for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
              const canvas = this.createPieceCanvas(img, col * pieceW, row * pieceH, pieceW, pieceH);
              
              const targetX = safeArea.left + col * finalSize;
              const targetY = safeArea.top + row * finalSize;

              // –í–∏–ø–∞–¥–∫–æ–≤—ñ –ø–æ–∑–∏—Ü—ñ—ó –∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º –º–µ–∂ –µ–∫—Ä–∞–Ω—É
              const randomX = this.getRandomPosition(20, screenWidth - finalSize - 20);
              const randomY = this.getRandomPosition(120, screenHeight - finalSize - 120);

              pieces.push({
                canvas: canvas,
                size: finalSize,
                x: randomX,
                y: randomY,
                targetX: targetX,
                targetY: targetY,
                isInPlace: false,
                row: row,
                col: col
              });
            }
          }

          // –ü–µ—Ä–µ–º—ñ—à—É–≤–∞–Ω–Ω—è
          this.shuffleArray(pieces);

          resolve({
            pieces: pieces,
            index: targetIndex,
            safeArea: safeArea
          });
        };
        
        img.onerror = () => {
          console.error('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è:', targetIndex);
          resolve(null);
        };
      });
    }

    createPieceCanvas(img, sx, sy, sw, sh) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è —Ä–æ–∑–º—ñ—Ä—É –¥–ª—è –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
      const maxSize = 400;
      const scale = Math.min(1, maxSize / Math.max(sw, sh));
      
      canvas.width = sw * scale;
      canvas.height = sh * scale;
      
      ctx.drawImage(img, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);
      return canvas;
    }

    getRandomPosition(min, max) {
      return Math.random() * (max - min) + min;
    }

    shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }
      return array;
    }

    setupPuzzleElements(targetIndex, pieces) {
      const targetContainer = document.getElementById('target-' + targetIndex);
      if (!targetContainer) return;
      
      targetContainer.innerHTML = '';

      pieces.forEach((piece, index) => {
        const plane = document.createElement('a-plane');
        const sizeInMeters = piece.size / 100;
        
        plane.setAttribute('src', piece.canvas.toDataURL('image/jpeg', 0.9));
        plane.setAttribute('width', sizeInMeters.toString());
        plane.setAttribute('height', sizeInMeters.toString());
        plane.setAttribute('position', this.getWebPosition(piece.x, piece.y));
        plane.setAttribute('data-target-pos', this.getWebPosition(piece.targetX, piece.targetY));
        plane.setAttribute('data-index', index.toString());
        plane.setAttribute('class', 'puzzle-piece');
        plane.setAttribute('material', 'transparent: true; alphaTest: 0.5;');
        
        targetContainer.appendChild(plane);
        piece.el = plane;
      });
    }

    getWebPosition(x, y) {
      const webX = (x - window.innerWidth / 2) / 100;
      const webY = (window.innerHeight / 2 - y) / 100;
      return webX + ' ' + webY + ' 0.02';
    }

    setupClickHandler(pieces) {
      this.clickHandler = (event) => {
        const pieceEl = event.detail?.intersectedEl;
        if (!pieceEl || !pieceEl.classList.contains('puzzle-piece') || !this.currentPuzzle) {
          return;
        }

        const pieceIndex = parseInt(pieceEl.getAttribute('data-index') || '0');
        this.handlePieceClick(pieceIndex, pieces);
      };

      const scene = document.querySelector('a-scene');
      if (scene) {
        scene.addEventListener('click', this.clickHandler);
      }
    }

    handlePieceClick(clickedIndex, pieces) {
      const clickedPiece = pieces[clickedIndex];
      if (!clickedPiece || clickedPiece.isInPlace) return;

      // –ó–Ω–∞–π—Ç–∏ —ñ–Ω—à–∏–π —Ä—É—Ö–æ–º–∏–π —à–º–∞—Ç–æ–∫
      const movablePieces = pieces.filter((p, idx) => 
        p.el && !p.isInPlace && idx !== clickedIndex
      );

      if (movablePieces.length === 0) return;
      
      const otherPiece = movablePieces[Math.floor(Math.random() * movablePieces.length)];
      const otherIndex = pieces.indexOf(otherPiece);

      if (!pieces[otherIndex]?.el) return;

      // –û–±–º—ñ–Ω –ø–æ–∑–∏—Ü—ñ—è–º–∏
      this.swapPieces(clickedPiece, pieces[otherIndex]);
      
      // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —á–∏ –ø–∞–∑–ª –∑—ñ–±—Ä–∞–Ω–æ
      this.checkWinCondition(pieces);
    }

    swapPieces(pieceA, pieceB) {
      const tempPos = pieceA.el.getAttribute('position');
      pieceA.el.setAttribute('position', pieceB.el.getAttribute('position'));
      pieceB.el.setAttribute('position', tempPos);

      // –û–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö –ø–æ–∑–∏—Ü—ñ–π
      const tempX = pieceA.x;
      const tempY = pieceA.y;
      pieceA.x = pieceB.x;
      pieceA.y = pieceB.y;
      pieceB.x = tempX;
      pieceB.y = tempY;
    }

    checkWinCondition(pieces) {
      if (!pieces) return false;

      const isSolved = pieces.every(piece => {
        const dx = Math.abs(piece.x - piece.targetX);
        const dy = Math.abs(piece.y - piece.targetY);
        return dx < 20 && dy < 20; // Tolerance –¥–ª—è –ø–æ–ª–µ–≥—à–µ–Ω–Ω—è –ø–µ—Ä–µ–º–æ–≥–∏
      });

      if (isSolved) {
        this.handleWin();
        return true;
      }
      return false;
    }

    handleWin() {
      this.showWinScreen();
      
      // –í—ñ–¥—Ç–≤–æ—Ä–µ–Ω–Ω—è –∑–≤—É–∫—É
      const audio = document.getElementById('yay');
      if (audio) {
        audio.play().catch(e => console.log('Audio play prevented:', e));
      }
      
      // –ï—Ñ–µ–∫—Ç –∫–æ–Ω—Ñ–µ—Ç—Ç—ñ
      if (typeof confetti === 'function') {
        confetti({ 
          particleCount: 300,
          spread: 100,
          origin: { y: 0.6 },
          colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff']
        });
        
        // –î–æ–¥–∞—Ç–∫–æ–≤—ñ —Ö–≤–∏–ª—ñ –∫–æ–Ω—Ñ–µ—Ç—Ç—ñ
        setTimeout(() => confetti({ particleCount: 200, angle: 60, spread: 80, origin: { x: 0 } }), 300);
        setTimeout(() => confetti({ particleCount: 200, angle: 120, spread: 80, origin: { x: 1 } }), 600);
      }

      this.updateHint('üéâ –í—ñ—Ç–∞—é! –ó–Ω–∞–π–¥–∏ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –º–∞—Ä–∫–µ—Ä!');

      if (this.clickHandler) {
        const scene = document.querySelector('a-scene');
        if (scene) {
          scene.removeEventListener('click', this.clickHandler);
        }
        this.clickHandler = null;
      }
    }

    handleResize() {
      if (this.resizeTimeout) clearTimeout(this.resizeTimeout);
      
      this.resizeTimeout = setTimeout(() => {
        if (this.currentPuzzle && this.activeTargetIndex !== null) {
          this.resetPuzzle();
          setTimeout(() => this.createPuzzle(this.activeTargetIndex), 400);
        }
      }, 400);
    }

    showLoading(message) {
      const loading = document.getElementById('loading');
      if (loading) {
        loading.textContent = message;
        loading.style.display = 'block';
      }
    }

    hideLoading() {
      const loading = document.getElementById('loading');
      if (loading) {
        loading.style.display = 'none';
      }
    }

    showWinScreen() {
      const winScreen = document.getElementById('win');
      if (winScreen) {
        winScreen.style.display = 'flex';
      }
    }

    hideWinScreen() {
      const winScreen = document.getElementById('win');
      if (winScreen) {
        winScreen.style.display = 'none';
      }
    }

    updateHint(message) {
      const hint = document.getElementById('hint');
      if (hint) {
        hint.textContent = message;
      }
    }
  }

  // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –≥—Ä–∏
  new MagicPuzzleGame();
});

// –î–æ–¥–∞—Ç–∫–æ–≤—ñ –∑–∞—Ö–æ–¥–∏ –¥–ª—è –ø—Ä–æ–∑–æ—Ä–æ—Å—Ç—ñ
setTimeout(() => {
  document.querySelectorAll('canvas').forEach(canvas => {
    if (!canvas.classList.contains('a-canvas')) {
      canvas.style.background = 'transparent';
    }
  });
}, 1000);
</script>
</body>
</html>
