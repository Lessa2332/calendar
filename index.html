<script type="module">
  // ================================================
  // КОНФІГУРАЦІЯ — 12 пазлів
  // ================================================
  const PUZZLES = Array.from({length:12}, (_,i) => ({
    id: i,
    image: `images/${String(i+1).padStart(2,'0')}.jpg`,
    rows: 3,
    cols: 3
  }));

  let currentEngine = null;

  // ================================================
  // ЕКРАНИ
  // ================================================
  const screens = {
    canvas: document.getElementById('puzzleCanvas'),
    closeBtn: document.getElementById('closeBtn'),
    start: document.getElementById('startScreen'),
    hint: document.getElementById('hintScreen'),
    win: document.getElementById('winScreen'),
    show(name) {
      [this.start, this.hint, this.win, this.canvas].forEach(el => el.style.display = 'none');
      this.closeBtn.style.display = 'none';
      if (name === 'puzzle') {
        this.canvas.style.display = 'block';
        this.closeBtn.style.display = 'block';
      } else {
        this[name].style.display = 'flex';
      }
    }
  };

  // ================================================
  // КОНФЕТІ
  // ================================================
  const celebrate = () => {
    confetti({particleCount:200,spread:100,origin:{y:0.6}});
    setTimeout(()=>confetti({particleCount:150,angle:60,spread:80,origin:{x:0}}),500);
    setTimeout(()=>confetti({particleCount:150,angle:120,spread:80,origin:{x:1}}),1000);
  };

  // ================================================
  // ЗАВАНТАЖЕННЯ ЗОБРАЖЕННЯ
  // ================================================
  const loadImage = src => new Promise((res, rej) => {
    const img = new Image();
    img.onload = () => res(img);
    img.onerror = () => rej();
    img.src = src;
  });

  // ================================================
  // РЕНДЕРЕР ПАЗЛУ
  // ================================================
  class PuzzleRenderer {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.resize();
      window.addEventListener('resize', () => this.resize());
    }
    resize() {
      this.canvas.width = innerWidth;
      this.canvas.height = innerHeight;
    }
    clear() { this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height); }
    draw(pieces, dragged = null) {
      this.clear();
      if (!pieces.length) return;

      const p = pieces[0];
      const pw = p.width * p.cols;
      const ph = p.height * p.rows;
      const cx = (this.canvas.width - pw) / 2;
      const cy = (this.canvas.height - ph) / 2;

      // Рамка
      this.ctx.strokeStyle = 'gold';
      this.ctx.lineWidth = 6;
      this.ctx.strokeRect(cx-10, cy-10, pw+20, ph+20);

      // Шматочки
      pieces.forEach(piece => {
        this.ctx.drawImage(piece.img, piece.x, piece.y, piece.width, piece.height);
        if (piece === dragged) {
          this.ctx.strokeStyle = '#ff1493';
          this.ctx.lineWidth = 4;
          this.ctx.strokeRect(piece.x, piece.y, piece.width, piece.height);
        }
      });

      // Підказка
      this.ctx.fillStyle = 'white';
      this.ctx.font = 'bold 28px Comic Sans MS';
      this.ctx.textAlign = 'center';
      this.ctx.fillText('Перетягуй шматочки пальчиком!', this.canvas.width/2, 80);
    }
  }

  // ================================================
  // ЛОГІКА ПАЗЛУ — 100% БЕЗ БАГІВ
  // ================================================
  class PuzzleEngine {
    constructor(config) {
      this.config = config;
      this.renderer = new PuzzleRenderer(document.getElementById('puzzleCanvas'));
      this.pieces = [];
      this.dragged = null;
      this.offset = {x:0,y:0};
      this.init();
    }

    async init() {
      try {
        const img = await loadImage(this.config.image);
        this.createPieces(img);
      } catch {
        this.createFallbackPieces();
      }
      this.bindEvents();
      this.renderer.draw(this.pieces);
    }

    createPieces(img) {
      const {rows, cols} = this.config;
      const pieceW = Math.min(180, innerWidth / 4);
      const pieceH = (img.height / img.width) * pieceW;
      const startX = (innerWidth - pieceW * cols) / 2;
      const startY = (innerHeight - pieceH * rows) / 2;

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const canvas = document.createElement('canvas');
          canvas.width = img.width / cols;
          canvas.height = img.height / rows;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, c*canvas.width, r*canvas.height, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);

          const pieceImg = new Image();
          pieceImg.src = canvas.toDataURL();

          this.pieces.push({
            img: pieceImg,
            x: Math.random() * (innerWidth - pieceW),
            y: Math.random() * (innerHeight - pieceH),
            targetX: startX + c * pieceW,
            targetY: startY + r * pieceH,
            width: pieceW,
            height: pieceH,
            placed: false
          });
        }
      }
      this.shuffle();
    }

    createFallbackPieces() {
      const colors = ['#FF6B6B','#4ECDC4','#45B7D1','#96CEB4','#FFEAA7','#DDA0DD','#98D8C8','#F7DC6F','#BB8FCE'];
      const size = 120;
      for (let i = 0; i < 9; i++) {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = colors[i];
        ctx.fillRect(0,0,size,size);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 50px Comic Sans MS';
        ctx.textAlign = 'center';
        ctx.fillText(i+1, size/2, size/2 + 18);

        const img = new Image();
        img.src = canvas.toDataURL();

        const row = Math.floor(i/3), col = i%3;
        this.pieces.push({
          img,
          x: Math.random() * (innerWidth - size),
          y: Math.random() * (innerHeight - size),
          targetX: (innerWidth - size*3)/2 + col*size,
          targetY: (innerHeight - size*3)/2 + row*size,
          width: size,
          height: size,
          placed: false
        });
      }
    }

    shuffle() {
      for (let i = this.pieces.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [this.pieces[i], this.pieces[j]] = [this.pieces[j], this.pieces[i]];
      }
    }

    bindEvents() {
      const canvas = this.renderer.canvas;

      const getPos = e => {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX || e.touches?.[0]?.clientX || 0) - rect.left;
        const y = (e.clientY || e.touches?.[0]?.clientY || 0) - rect.top;
        return {x, y};
      };

      const start = e => {
        const {x, y} = getPos(e);
        for (let i = this.pieces.length - 1; i >= 0; i--) {
          const p = this.pieces[i];
          if (x >= p.x && x <= p.x + p.width && y >= p.y && y <= p.y + p.height) {
            this.dragged = p;
            this.offset = {x: x - p.x, y: y - p.y};
            this.pieces.splice(i, 1);
            this.pieces.push(p);
            break;
          }
        }
      };

      const move = e => {
        if (!this.dragged) return;
        e.preventDefault();
        const {x, y} = getPos(e);
        this.dragged.x = x - this.offset.x;
        this.dragged.y = y - this.offset.y;
        this.renderer.draw(this.pieces, this.dragged);
      };

      const end = () => {
        if (!this.dragged) return;

        const dx = this.dragged.x + this.dragged.width/2 - (this.dragged.targetX + this.dragged.width/2);
        const dy = this.dragged.y + this.dragged.height/2 - (this.dragged.targetY + this.dragged.height/2);
        if (Math.hypot(dx, dy) < 50) {
          this.dragged.x = this.dragged.targetX;
          this.dragged.y = this.dragged.targetY;
          this.dragged.placed = true;
        }

        if (this.pieces.every(p => p.placed)) {
          celebrate();
          setTimeout(() => screens.show('win'), 2000);
          setTimeout(() => {
            currentEngine = null;
            screens.show('hint');
          }, 6000);
        } else {
          this.renderer.draw(this.pieces);
        }

        this.dragged = null;
      };

      canvas.addEventListener('mousedown', start);
      canvas.addEventListener('touchstart', start, {passive:false});
      canvas.addEventListener('mousemove', move);
      canvas.addEventListener('touchmove', move, {passive:false});
      canvas.addEventListener('mouseup', end);
      canvas.addEventListener('touchend', end);
    }
  }

  // ================================================
  // ЗАПУСК MINDAR — З ПЕРЕВІРКОЮ СИСТЕМИ (ВІДПОВІДНО ДО ДОКУМЕНТАЦІЇ)
  // ================================================
  const sceneEl = document.querySelector('a-scene');

  document.getElementById('startBtn').onclick = async () => {
    if (window.mindarStarted) return;
    window.mindarStarted = true;

    screens.show('hint');

    // Чекаємо завантаження A-Frame (як у документації)
    if (!sceneEl.hasLoaded) {
      await new Promise(r => sceneEl.addEventListener('loaded', r, {once: true}));
      console.log('A-Frame завантажено');
    }

    // ТЕПЕР ЧЕКАЄМО РЕЄСТРАЦІЇ MINDAR СИСТЕМИ (ключове виправлення!)
    const waitForMindARSystem = () => new Promise((resolve, reject) => {
      let attempts = 0;
      const maxAttempts = 50; // 5 секунд (100ms * 50)
      const check = () => {
        attempts++;
        const system = sceneEl.systems['mindar-image-system'];
        if (system) {
          console.log('MindAR система готова!');
          resolve(system);
        } else if (attempts < maxAttempts) {
          setTimeout(check, 100); // Чекаємо 100ms
        } else {
          console.error('MindAR система не зареєструвалася');
          reject(new Error('MindAR не завантажився'));
        }
      };
      check();
    });

    try {
      // Чекаємо систему (це виправляє "undefined.start"!)
      const mindarSystem = await waitForMindARSystem();

      // Запускаємо камеру
      await mindarSystem.start();
      console.log('Камера запущена!');

      // Додаємо 12 маркерів
      PUZZLES.forEach(conf => {
        const entity = document.createElement('a-entity');
        entity.setAttribute('mindar-image-target', `targetIndex: ${conf.id}`);
        entity.addEventListener('targetFound', () => {
          console.log(`Маркер ${conf.id} знайдено!`);
          if (!currentEngine) {
            currentEngine = new PuzzleEngine(conf);
            screens.show('puzzle');
          }
        });
        entity.addEventListener('targetLost', () => {
          console.log(`Маркер ${conf.id} втрачено`);
        });
        sceneEl.appendChild(entity);
      });

    } catch (err) {
      console.error('Помилка запуску:', err);
      alert('Не вдалося увімкнути камеру. Перевірте дозволи або оновіть сторінку.');
      window.mindarStarted = false;
    }
  };

  document.getElementById('closeBtn').onclick = () => {
    currentEngine = null;
    screens.show('hint');
  };

  // Початковий екран
  screens.show('start');
</script>
