<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
  <title>Магічний пазл для зірочки</title>

  <!-- Найкраща комбінація 2025 року -->
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@2.2.1/dist/mindar-image-aframe.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body, html {
      height:100%; overflow:hidden; background:#000;
      font-family:'Comic Sans MS', cursive, sans-serif;
      touch-action: none;
    }

    /* Гарантія видимості камери */
    a-scene canvas, video { background:transparent !important; }
    .mindar-ui-overlay { background:transparent !important; }

    #hint {
      position:fixed; top:max(20px, env(safe-area-inset-top,20px)); left:50%; transform:translateX(-50%);
      background:linear-gradient(135deg,#ff1493,#ff69b4); color:#fff;
      padding:16px 32px; border-radius:50px; font-size:clamp(18px,5vw,28px);
      z-index:999; box-shadow:0 0 40px rgba(255,20,147,0.8); text-align:center;
      border:3px solid white; animation:pulse 2s infinite;
    }

    #loading {
      position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
      background:rgba(0,0,0,0.9); color:#fff; padding:20px 40px; border-radius:20px;
      font-size:24px; z-index:1001; display:none;
    }

    #win {
      position:fixed; inset:0; background:rgba(0,0,0,0.97); color:gold;
      display:none; flex-direction:column; align-items:center; justify-content:center;
      z-index:1000; text-align:center; padding:20px;
    }
    #win span { font-size:clamp(50px,12vw,100px); animation:bounce 1s infinite; }
    #win p { font-size:clamp(24px,6vw,40px); color:#ff69b4; margin-top:20px; }

    @keyframes pulse { 0%,100% {opacity:1} 50% {opacity:0.7} }
    @keyframes bounce { 0%,100% {transform:scale(1)} 50% {transform:scale(1.2)} }
  </style>
</head>
<body>

  <div id="hint">Натисни на екран, щоб почати магію!</div>
  <div id="loading">Запускаємо камеру...</div>

  <div id="win">
    <span>УРААА!</span>
    <p>Ти найкращий чарівник!</p>
  </div>

  <a-scene
    embedded
    mindar-image="imageTargetSrc: calendar.mind; uiLoading: no; uiError: no; uiScanning: no; autoStart: false; filterMinCF: 0.0001; filterBeta: 1000;"
    renderer="colorManagement: true; alpha: true;"
    vr-mode-ui="enabled: false"
    device-orientation-permission-ui="enabled: false">
    
    <a-camera active="true"></a-camera>
    <a-entity id="targets-container"></a-entity>
  </a-scene>

  <audio id="yay" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3" preload="auto"></audio>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      class MagicPuzzleGame {
        constructor() {
          this.activeTargetIndex = null;
          this.clickHandler = null;
          this.init();
        }

        init() {
          this.createTargets();
          this.setupVideoFix();
          this.setupStartClick();
        }

        createTargets() {
          const container = document.getElementById('targets-container');
          for (let i = 0; i < 12; i++) {
            const el = document.createElement('a-entity');
            el.setAttribute('mindar-image-target', 'targetIndex: ' + i);
            el.id = 'target-' + i;
            container.appendChild(el);
          }
        }

        // Гарантія видимості камери
        setupVideoFix() {
          const observer = new MutationObserver(() => {
            const video = document.querySelector('video');
            if (video) {
              video.style.cssText = 'position:fixed !important; top:0; left:0; width:100%; height:100%; object-fit:cover; z-index:-1;';
              observer.disconnect();
            }
          });
          observer.observe(document.body, { childList: true, subtree: true });
        }

        // КРИТИЧНИЙ ФІКС: правильний запуск після кліку
        setupStartClick() {
          document.body.addEventListener('click', async () => {
            document.getElementById('hint').textContent = 'Запускаємо камеру...';
            document.getElementById('loading').style.display = 'block';

            try {
              const scene = document.querySelector('a-scene');
              const mindar = scene.systems['mindar-image-system'];
              if (mindar && !mindar.initialized) {
                await mindar.start();
              }
              document.getElementById('hint').textContent = 'Знайди маркер у календарі!';
              this.setupTracking();
            } catch (err) {
              console.error(err);
              document.getElementById('hint').textContent = 'Помилка камери! Дозволь доступ!';
            } finally {
              document.getElementById('loading').style.display = 'none';
            }
          }, { once: true });
        }

        setupTracking() {
          const scene = document.querySelector('a-scene');
          scene.addEventListener('targetFound', (e) => {
            const idx = e.detail.targetIndex;
            if (this.activeTargetIndex === idx) return;
            this.resetPuzzle();
            this.activeTargetIndex = idx;
            setTimeout(() => this.createPuzzle(idx), 600);
          });

          scene.addEventListener('targetLost', () => {
            if (this.activeTargetIndex !== null) this.resetPuzzle();
          });
        }

        async createPuzzle(index) {
          document.getElementById('loading').style.display = 'block';
          document.getElementById('loading').textContent = 'Створюємо пазл...';

          const num = String(index + 1).padStart(2, '0');
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.src = `images/${num}.jpg?t=${Date.now()}`;

          img.onload = () => {
            const pieces = this.generatePieces(img);
            this.renderPieces(index, pieces);
            document.getElementById('hint').textContent = 'Клацай шматочки — збирай пазл!';
            document.getElementById('loading').style.display = 'none';
          };

          img.onerror = () => {
            document.getElementById('hint').textContent = 'Не вдалося завантажити зображення';
            document.getElementById('loading').style.display = 'none';
          };
        }

        generatePieces(img) {
          const rows = 3, cols = 3;
          const w = window.innerWidth, h = window.innerHeight;
          const pieceSize = Math.min(w, h) / (w > h ? 4 : 3.5);
          const pieces = [];

          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              canvas.width = canvas.height = 400;
              ctx.drawImage(img, c * img.width/cols, r * img.height/rows, img.width/cols, img.height/rows, 0, 0, 400, 400);

              const targetX = w/2 - pieceSize*1.5 + c*pieceSize;
              const targetY = h/2 - pieceSize*1.5 + r*pieceSize + 100;

              pieces.push({
                dataURL: canvas.toDataURL(),
                size: pieceSize / 100,
                x: 50 + Math.random()*(w-100-pieceSize),
                y: 150 + Math.random()*(h-300),
                targetX, targetY,
                correct: false
              });
            }
          }
          return this.shuffle(pieces);
        }

        shuffle(a) { for (let i = a.length-1; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]] = [a[j],a[i]]; } return a; }

        renderPieces(targetIndex, pieces) {
          const container = document.getElementById('target-' + targetIndex);
          container.innerHTML = '';

          pieces.forEach((p, i) => {
            const plane = document.createElement('a-plane');
            plane.setAttribute('src', p.dataURL);
            plane.setAttribute('width', p.size);
            plane.setAttribute('height', p.size);
            plane.setAttribute('position', this.toWorldPos(p.x, p.y));
            plane.setAttribute('data-index', i);
            plane.setAttribute('class', 'puzzle-piece');
            plane.setAttribute('material', 'transparent: true; alphaTest: 0.1');
            container.appendChild(plane);
            p.el = plane;
          });

          this.setupClickHandler(pieces);
        }

        toWorldPos(x, y) {
          return `${(x - window.innerWidth/2)/100} ${(window.innerHeight/2 - y)/100} 0.02`;
        }

        setupClickHandler(pieces) {
          if (this.clickHandler) document.querySelector('a-scene').removeEventListener('click', this.clickHandler);

          this.clickHandler = (e) => {
            const el = e.detail?.intersectedEl;
            if (!el || !el.classList.contains('puzzle-piece')) return;

            const idx = +el.getAttribute('data-index');
            const clicked = pieces[idx];
            if (clicked.correct) return;

            const free = pieces.filter(p => p.el && !p.correct && p !== clicked);
            if (free.length === 0) return;

            const other = free[Math.floor(Math.random() * free.length)];
            const temp = el.getAttribute('position');
            el.setAttribute('position', other.el.getAttribute('position'));
            other.el.setAttribute('position', temp);

            this.checkWin(pieces);
          };

          document.querySelector('a-scene').addEventListener('click', this.clickHandler);
        }

        checkWin(pieces) {
          const tolerance = 40;
          const allCorrect = pieces.every(p => {
            const pos = p.el.getAttribute('position');
            const dx = Math.abs(pos.x*100 + window.innerWidth/2 - p.targetX);
            const dy = Math.abs(window.innerHeight/2 - pos.y*100 - p.targetY);
            const correct = dx < tolerance && dy < tolerance;
            p.correct = correct;
            return correct;
          });

          if (allCorrect) this.victory();
        }

        victory() {
          document.getElementById('win').style.display = 'flex';
          document.getElementById('hint').textContent = 'Вітаю! Знайди наступний маркер!';

          document.getElementById('yay').play().catch(() => {});

          if (typeof confetti === 'function') {
            confetti({ particleCount: 300, spread: 100, origin: { y: 0.6 } });
            setTimeout(() => confetti({ particleCount: 200, angle: 60, spread: 80, origin: { x: 0 } }), 300);
            setTimeout(() => confetti({ particleCount: 200, angle: 120, spread: 80, origin: { x: 1 } }), 600);
          }

          if (this.clickHandler) {
            document.querySelector('a-scene').removeEventListener('click', this.clickHandler);
            this.clickHandler = null;
          }
        }

        resetPuzzle() {
          for (let i = 0; i < 12; i++) {
            const el = document.getElementById('target-' + i);
            if (el) el.innerHTML = '';
          }
          document.getElementById('win').style.display = 'none';
          this.activeTargetIndex = null;
        }
      }

      // Запуск гри
      new MagicPuzzleGame();
    });
  </script>
</body>
</html>
