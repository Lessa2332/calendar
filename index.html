<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Magical Ukraine Calendar 2026</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      touch-action: none;
    }
    #mindar-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) 
                env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    #info {
      text-align: center;
      color: white;
      text-shadow: 0 0 10px #00ffff;
      padding: 10px 16px;
      background: rgba(0,0,0,0.5);
      border-radius: 12px;
      font-size: clamp(14px, 4vw, 18px);
      line-height: 1.4;
      max-width: 90%;
      margin: 0 auto;
      pointer-events: none;
    }
    #top-bar {
      display: flex;
      justify-content: space-between;
      padding: 10px 12px;
      gap: 10px;
    }
    .lang-btn, .etsy-btn {
      pointer-events: auto;
      background: rgba(0, 200, 255, 0.2);
      border: 1px solid #00ffff;
      color: white;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 14px;
      cursor: pointer;
      backdrop-filter: blur(4px);
    }
    .lang-btn:hover, .etsy-btn:hover {
      background: rgba(0, 200, 255, 0.4);
    }
    #crystals {
      display: flex;
      gap: clamp(8px, 3vw, 14px);
      justify-content: center;
      padding: 0 8px 20px;
    }
    .crystal-slot {
      width: clamp(40px, 12vw, 56px);
      height: clamp(40px, 12vw, 56px);
      border: 2px solid #00ffff77;
      border-radius: 50%;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(24px, 7vw, 36px);
      color: white;
    }
  </style>
</head>
<body>

<div id="mindar-container"></div>
<div id="ui">
  <div id="top-bar">
    <button class="lang-btn" id="lang-toggle">Українська</button>
    <button class="etsy-btn" id="etsy-link">Shop on Etsy</button>
  </div>
  <div id="info">Point your camera at the calendar marker ❤️</div>
  <div id="crystals"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.10/dist/mindar-target.prod.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.10/dist/mindar-target-three.prod.js"></script>

<script>
// === Мови ===
const translations = {
  en: {
    infoScan: "Point your camera at the calendar marker ❤️",
    infoComplete: "UKRAINE'S HEART IS COMPLETE!<br>You are a true hero ❤️",
    langBtn: "Українська",
    etsyBtn: "Shop on Etsy"
  },
  uk: {
    infoScan: "Наведи камеру на маркер календаря ❤️",
    infoComplete: "СЕРЦЕ УКРАЇНИ ЗІБРАНО!<br>Ти — справжній герой ❤️",
    langBtn: "English",
    etsyBtn: "Купити на Etsy"
  }
};

let currentLang = 'en';
const DPR = window.devicePixelRatio || 1;

// === Локалізація ===
function setLang(lang) {
  currentLang = lang;
  localStorage.setItem('calendar-lang', lang);
  const t = translations[lang];
  document.getElementById('info').innerHTML = t.infoScan;
  document.getElementById('lang-toggle').textContent = t.langBtn;
  document.getElementById('etsy-link').textContent = t.etsyBtn;
  updateCrystalsUI();
}

// Ініціалізація мови
const savedLang = localStorage.getItem('calendar-lang');
if (savedLang === 'uk') setLang('uk');

// === Події кнопок ===
document.getElementById('lang-toggle').addEventListener('click', () => {
  setLang(currentLang === 'en' ? 'uk' : 'en');
});
document.getElementById('etsy-link').addEventListener('click', () => {
  window.open('https://smartlessa.etsy.com', '_blank');
});

// === Дані ===
let collectedCrystals = JSON.parse(localStorage.getItem('ua-crystals2026') || '[]');
const totalMonths = 12;

// === MindAR ===
const mindarThree = new MindARThree.Target({
  container: document.getElementById('mindar-container'),
  imageTargetSrc: 'calendar.mind',
  maxTrack: 1,
  uiScanning: currentLang === 'uk' ? "Шукаємо маркер..." : "Scanning for marker...",
  uiLoading: currentLang === 'uk' ? "Завантажуємо..." : "Loading...",
  filterMinCF: 0.0001,
  filterBeta: 0.0001
});

const { renderer, scene, camera } = mindarThree;
renderer.setPixelRatio(DPR);
renderer.setSize(window.innerWidth, window.innerHeight);

// Світло
const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
directionalLight.position.set(5, 10, 7);
scene.add(directionalLight);
scene.add(new THREE.AmbientLight(0xffffff, 0.7));

// Один AR група для маркера
const arGroup = new THREE.Group();
const targetGroup = mindarThree.addAnchor(0);
targetGroup.group.add(arGroup);

// Змінні для крапель та калюжі
let drops = [];
let puddle = null;
let dropInterval = null;
let isPuddleActive = false;

// Ресайз
function onWindowResize() {
  const w = window.innerWidth, h = window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
}
window.addEventListener('resize', onWindowResize, { passive: true });
window.addEventListener('orientationchange', () => setTimeout(onWindowResize, 300));

// Уніфікований тач
const isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
function addUnifiedTouch(el, onStart, onMove, onEnd) {
  if (isMobile) {
    el.addEventListener('touchstart', e => { e.preventDefault(); onStart(e.touches[0]); }, { passive: false });
    el.addEventListener('touchmove', e => { e.preventDefault(); onMove(e.touches[0]); }, { passive: false });
    el.addEventListener('touchend', e => { e.preventDefault(); onEnd(); }, { passive: false });
  } else {
    el.addEventListener('mousedown', e => onStart(e));
    el.addEventListener('mousemove', e => { if (el.dragging) onMove(e); });
    el.addEventListener('mouseup', onEnd);
    el.addEventListener('mouseleave', onEnd);
  }
}

// Шейдер для краплі з рефракцією
const dropVertexShader = `
  varying vec3 vNormal;
  varying vec3 vViewPosition;
  void main() {
    vNormal = normalize(normalMatrix * normal);
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    vViewPosition = -mvPosition.xyz;
    gl_Position = projectionMatrix * mvPosition;
  }
`;

const dropFragmentShader = `
  uniform float time;
  varying vec3 vNormal;
  varying vec3 vViewPosition;
  
  void main() {
    vec3 normal = normalize(vNormal);
    vec3 viewDir = normalize(vViewPosition);
    
    // Рефракція
    float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0);
    
    // Колір води з легким блакитним відтінком
    vec3 waterColor = vec3(0.4, 0.6, 0.9);
    vec3 refractColor = mix(waterColor, vec3(1.0), fresnel * 0.3);
    
    // Додаємо динамічні відблиски
    float sparkle = sin(time * 5.0 + vViewPosition.x * 10.0) * 0.2 + 0.8;
    
    gl_FragColor = vec4(refractColor * sparkle, 0.9 - fresnel * 0.3);
  }
`;

// Шейдер для калюжі з хвилями
const puddleVertexShader = `
  uniform float time;
  uniform vec2 touchPoint;
  uniform float touchStrength;
  varying vec2 vUv;
  
  void main() {
    vUv = uv;
    
    vec3 newPosition = position;
    
    // Генерація хвиль від торкання
    if (touchStrength > 0.0) {
      float dist = distance(uv, touchPoint);
      float wave = exp(-dist * 10.0) * sin(dist * 20.0 - time * 8.0) * touchStrength;
      newPosition.z += wave * 0.1;
    }
    
    // Легка ряб від часу
    float ripple = sin(time * 2.0 + uv.x * 15.0) * sin(time * 1.7 + uv.y * 12.0) * 0.01;
    newPosition.z += ripple;
    
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
  }
`;

const puddleFragmentShader = `
  uniform float time;
  uniform vec2 touchPoint;
  uniform float touchStrength;
  varying vec2 vUv;
  
  void main() {
    // Основний колір калюжі
    vec3 baseColor = vec3(0.2, 0.4, 0.8);
    
    // Відблиски
    float shine = sin(time * 3.0 + vUv.x * 8.0) * 0.1 + 0.9;
    
    // Кільця хвиль від торкання
    float waveRing = 0.0;
    if (touchStrength > 0.0) {
      float dist = distance(vUv, touchPoint);
      waveRing = sin(dist * 30.0 - time * 10.0) * touchStrength * exp(-dist * 8.0);
    }
    
    // Текстура води
    float waterPattern = sin(time + vUv.x * 20.0) * sin(time * 1.3 + vUv.y * 18.0) * 0.1;
    
    vec3 finalColor = baseColor * shine + vec3(0.3, 0.5, 0.9) * waveRing + waterPattern;
    float alpha = 0.7 + waveRing * 0.3;
    
    gl_FragColor = vec4(finalColor, alpha);
  }
`;

// Функція створення краплі
function createDrop() {
  const geometry = new THREE.SphereGeometry(0.05, 16, 16);
  const material = new THREE.ShaderMaterial({
    vertexShader: dropVertexShader,
    fragmentShader: dropFragmentShader,
    uniforms: {
      time: { value: 0 }
    },
    transparent: true,
    side: THREE.DoubleSide
  });

  const drop = new THREE.Mesh(geometry, material);
  
  // Випадкова позиція згори
  drop.position.set(
    (Math.random() - 0.5) * 1.5,
    1.5,
    (Math.random() - 0.5) * 1.5
  );
  
  drop.userData = {
    velocity: 0,
    speed: 0.02 + Math.random() * 0.01
  };
  
  arGroup.add(drop);
  drops.push(drop);
  
  return drop;
}

// Функція створення калюжі
function createPuddle() {
  const geometry = new THREE.PlaneGeometry(2, 2, 32, 32);
  const material = new THREE.ShaderMaterial({
    vertexShader: puddleVertexShader,
    fragmentShader: puddleFragmentShader,
    uniforms: {
      time: { value: 0 },
      touchPoint: { value: new THREE.Vector2(0.5, 0.5) },
      touchStrength: { value: 0 }
    },
    transparent: true,
    side: THREE.DoubleSide
  });

  puddle = new THREE.Mesh(geometry, material);
  puddle.rotation.x = -Math.PI / 2;
  puddle.position.y = 0.01;
  
  arGroup.add(puddle);
  isPuddleActive = true;
  
  return puddle;
}

// Анімація крапель
function animateDrops() {
  const currentTime = Date.now() * 0.001;
  
  // Оновлюємо краплі
  for (let i = drops.length - 1; i >= 0; i--) {
    const drop = drops[i];
    drop.userData.velocity += drop.userData.speed;
    drop.position.y -= drop.userData.velocity;
    
    // Оновлюємо час у шейдері
    drop.material.uniforms.time.value = currentTime;
    
    // Перевіряємо чи крапля впала
    if (drop.position.y <= 0.05) {
      // Видаляємо краплю
      arGroup.remove(drop);
      drops.splice(i, 1);
      
      // Створюємо калюжу якщо ще немає
      if (!isPuddleActive) {
        createPuddle();
      }
    }
  }
  
  // Оновлюємо калюжу
  if (puddle) {
    puddle.material.uniforms.time.value = currentTime;
    
    // Зменшуємо силу торкання з часом
    if (puddle.material.uniforms.touchStrength.value > 0) {
      puddle.material.uniforms.touchStrength.value *= 0.95;
      if (puddle.material.uniforms.touchStrength.value < 0.01) {
        puddle.material.uniforms.touchStrength.value = 0;
      }
    }
  }
}

// Обробка торкання калюжі
function handlePuddleTouch(touch) {
  if (!puddle || !isPuddleActive) return;
  
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((touch.clientX - rect.left) / rect.width);
  const y = 1 - ((touch.clientY - rect.top) / rect.height);
  
  // Оновлюємо точку торкання в шейдері
  puddle.material.uniforms.touchPoint.value.set(x, y);
  puddle.material.uniforms.touchStrength.value = 1.0;
}

// === Запуск AR ===
mindarThree.start().then(() => {
  let isVisible = false;
  
  // Запускаємо генерацію крапель
  dropInterval = setInterval(() => {
    if (isVisible && drops.length < 15) {
      createDrop();
    }
  }, 500);
  
  const animate = () => {
    renderer.render(scene, camera);
    const currentVisible = targetGroup.visible;
    
    if (currentVisible !== isVisible) {
      if (!currentVisible) {
        // Маркер втрачено - очищаємо сцену
        arGroup.clear();
        drops = [];
        puddle = null;
        isPuddleActive = false;
      } else {
        // Маркер знайдено - запускаємо анімацію
        isPuddleActive = false;
      }
      isVisible = currentVisible;
    }
    
    // Анімуємо краплі та калюжу
    if (isVisible) {
      animateDrops();
    }
    
    requestAnimationFrame(animate);
  };
  
  // Додаємо обробку торкання для калюжі
  addUnifiedTouch(renderer.domElement, 
    (touch) => { handlePuddleTouch(touch); },
    () => {},
    () => {}
  );
  
  animate();
}).catch(e => {
  document.getElementById('info').innerHTML = currentLang === 'uk' 
    ? "❌ Дозволь доступ до камери або онови сторінку." 
    : "❌ Please allow camera access or refresh the page.";
  console.error("AR initialization failed:", e);
});

// Функція для показу кристала
function showCrystalReward() {
  const month = 0; // Для одного маркера
  
  if (collectedCrystals.includes(month)) return;
  collectedCrystals.push(month);
  localStorage.setItem('ua-crystals2026', JSON.stringify(collectedCrystals));
  updateCrystalsUI();

  // Зупиняємо краплі
  clearInterval(dropInterval);
  drops.forEach(drop => arGroup.remove(drop));
  drops = [];
  if (puddle) arGroup.remove(puddle);
  isPuddleActive = false;

  arGroup.clear();
  const colors = ['#00ffff','#ff00ff','#00ff00','#ffff00','#ff8800','#ff0066','#0066ff','#ff3399','#33ff99','#ffcc00','#cc00ff','#00ccff'];
  const crystal = new THREE.Mesh(
    new THREE.IcosahedronGeometry(0.35, 1),
    new THREE.MeshStandardMaterial({
      color: colors[month],
      emissive: colors[month],
      emissiveIntensity: 4,
      roughness: 0,
      metalness: 0.85
    })
  );
  crystal.position.z = 0.2;
  arGroup.add(crystal);

  const animateCrystal = () => {
    if (!arGroup.parent) return;
    crystal.rotation.y += 0.015;
    crystal.scale.setScalar(1 + Math.sin(Date.now()*0.004)*0.08);
    requestAnimationFrame(animateCrystal);
  };
  animateCrystal();

  // Для одного маркера - одразу показуємо серце
  setTimeout(() => {
    arGroup.clear();
    const heart = new THREE.Group();
    const geo = new THREE.BufferGeometry();
    const vertices = [];
    const c = Math.random() > 0.5 ? 0x0057b7 : 0xffd700;
    for (let i = 0; i < 2500; i++) {
      const a = Math.random() * Math.PI * 2;
      const r = Math.random() * 1.2;
      vertices.push(Math.cos(a)*r, Math.sin(a)*r + (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    const pts = new THREE.Points(geo, new THREE.PointsMaterial({
      color: c,
      size: window.innerWidth > 600 ? 0.05 : 0.03,
      transparent: true,
      opacity: 0.95
    }));
    heart.add(pts);
    arGroup.add(heart);
    document.getElementById('info').innerHTML = translations[currentLang].infoComplete;
  }, 2000);
}

function updateCrystalsUI() {
  const container = document.getElementById('crystals');
  container.innerHTML = '';
  for (let i = 0; i < totalMonths; i++) {
    const div = document.createElement('div');
    div.className = 'crystal-slot';
    div.innerHTML = collectedCrystals.includes(i) ? '✦' : (i+1);
    div.style.background = collectedCrystals.includes(i) 
      ? 'linear-gradient(45deg, #00ffff, #ff00ff)' 
      : 'rgba(0,0,0,0.7)';
    container.appendChild(div);
  }
}

// Додаємо обробник для активації кристала при довгому торканні калюжі
let touchStartTime = 0;
addUnifiedTouch(renderer.domElement, 
  (touch) => { 
    touchStartTime = Date.now();
    handlePuddleTouch(touch);
  },
  () => {},
  () => {
    if (Date.now() - touchStartTime > 1000) { // Довге торкання > 1 секунди
      showCrystalReward();
    }
  }
);

updateCrystalsUI();
</script>

</body>
</html>
